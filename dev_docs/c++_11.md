
#	构造/析构函数

### new 和 exception 
C++ 标准中是规定new 不会返回null,只能抛出异常，有些旧的编译器允许以下方式返回异常

As per the current standard,  _new_  never returns  _NULL_, it throws a std::bad_alloc instead. If you don't want new to throw(as per the old standard) but rather return NULL you should call it by postfixing it with "_(std::nothrow)_". i.e.
```
Foo* foo = new (std::nothrow) Foo;
```
但这不符合标准
可以参见12.1

### ctor 和copy ctor之间的关系
非独立:如果声明了copy ctor, 就不会再产生ctor, 如果user调用？会说 no appropriate default constructor available,可以理解为既然有了自定义的copy ctor,那么ctor上必定有些特殊的地方，需要自己定义。
```
// ctor
class CtorTest
{
public:        
    CtorTest(const CtorTest &rhs) {
        std::cout << "copy ctor" << std::endl;
    }
    ~CtorTest() {
        std::cout << "dtor" << std::endl;
    }
};
void ctor_test()
{
    CtorTest obj;//error,编译器并不会自动产生ctor了，因为已声明了copy ctor
}
```

而声明ctor并不影响copy ctor

Copy ctor 的参数必须为引用，但不一定是const,像auto_ptr的copy ctor就不是const

**禁止构造函数**
这名字起的不好,应该是nonctor
```
Class noncopy {
public:
	noncopy() = delete;
};
```

error C2280: 'noncopy::noncopy(void)' : attempting to reference a deleted function

bind的时候主义为指针，
m_server_.setMessageCallback(boost::bind(&EchoCodec::onCodecCallback, &m_codec_, _1, _2));
否则可能调用copy ctor


### 为什么没有default operator ==

https://stackoverflow.com/questions/217911/why-dont-c-compilers-define-operator-and-operator

Why don't C++ compilers define operator== and operator!=?

论点主要有提供灵活度，由developer实现，编译器很难知道用户的正确意图，a=b之后必须要有a==b,这个很难做到
大佬说可能会在C++17之后，目前提案还没看到。
https://isocpp.org/blog/2016/02/a-bit-of-background-for-the-default-comparison-proposal-bjarne-stroustrup


## Sleep & chrono
```

std::chrono::seconds fivesec(5);
while (1) {
    std::cout << "block receiving\n";
    std::this_thread::sleep_for(fivesec);
}

#include <boost/chrono.hpp>
boost::chrono::seconds fivesec(5);
boost::this_thread::sleep_for(fivesec);
```


### noncopyable意义 TBD
```
class noncopyable
{
  protected:
#if !defined(BOOST_NO_CXX11_DEFAULTED_FUNCTIONS) && !defined(BOOST_NO_CXX11_NON_PUBLIC_DEFAULTED_FUNCTIONS)
      BOOST_CONSTEXPR noncopyable() = default;
      ~noncopyable() = default;
#else
      noncopyable() {}
      ~noncopyable() {}
#endif
#if !defined(BOOST_NO_CXX11_DELETED_FUNCTIONS)
      noncopyable( const noncopyable& ) = delete;
      noncopyable& operator=( const noncopyable& ) = delete;
#else
  private:  // emphasize the following members are private
      noncopyable( const noncopyable& );
      noncopyable& operator=( const noncopyable& );
#endif
};
```
将ctor,dtor声明为protected,默认,
将copy ctor以及assignment 声明为private.

如果不派生noncopyable,意味着需要dtor里负责资源释放
默认情况下应该加上noncopyable,因为他确实不能copy







#	类型
## auto
参见 EMC 第一章
打印类型
```
cout << typeid(T).name() << endl; 
```

auto, decltype
typeid(T).name()  打印T的名字

## any
boost::any &std::any
C++11中不包含any, 但C++14 中有草案.C++17中可能是std::variant
```
if (actual.type() == typeid(string)) {
    strRet = boost::lexical_cast<string>(boost::any_cast<string>(actual));
    strExp = boost::lexical_cast<string>(boost::any_cast<string>(exp));			
}	
else if (actual.type() == typeid(int)) {
    strRet = boost::lexical_cast<string>(boost::any_cast<int>(actual));
    strExp = boost::lexical_cast<string>(boost::any_cast<int>(exp));
}
```
boost::any(x) 把x转换为any.

//boost::any value(string("White"));
boost::any value(1);
string str = any_cast<string>(value); //这样会抛出一个bad_any_cast

any_iterator
(CSDN 2008)
concept

##	decltype

用于让编译器找出表达式的类型，其实这是常被要求的typeof的特性，只不过原有的typeof缺乏一致性又不完全。
用于yield出实际的类型:(Yields the type of an expression without evaluating it. 获得一个表达式的类型而无需evaluating.)
```
struct A { double x; };
const A* a = new A{0};
 
decltype(a->x) y;       // type of y is double (declared type)
decltype((a->x)) z = y; // type of z is const double& (lvalue expression)
int x, *ptr;
decltype(x) i1;  // i1’s type is int
decltype(ptr) p1;  // p1’s type is int*
std::size_t sz = sizeof(decltype(ptr[44])); // sz = sizeof(int); 
```
For lvalue expressions of type T other than names, decltype always reports a type of T&

###	用来声明返回值
C++11
当返回类型所参考的对象还未被引入，无法知道真实的返回类型，可以如下处理让compiler来推导
```
template<typename FuncType,typename MuxType,typename PtrType>
auto lockAndCall(FuncType func,MuxType& mutex,PtrType ptr) -> decltype(func(ptr))
{
  LockGuard g(mutex);
  return func(ptr);
}

template<typename T, typename U>
auto add(T t, U u) -> decltype(t + u) // return type depends on template parameters
{
    return t+u;
}
```

### C++14语法-decltype
```
template<typename FuncType,typename MuxType,typename PtrType>
decltype(auto) lockAndCall(FuncType func, MuxType& mutex,PtrType ptr)
{
  MuxGuard g(mutex);
  return func(ptr);
}
```
声明就是auto原先的类型，而不要去掉&

区别?
```
template<typename Container, typename Index> // final
auto authAndAccess(Container&& c, Index i) -> decltype(std::forward<Container>(c)[i])
{
    // do something
    return std::forward<Container>(c)[i];
}

template<typename Container, typename Index> // final
auto authAndAccess1(Container&& c, Index i) -> decltype(c[i])
{    
    return c[i];
}
```

###	双重decltype((x))
```
decltype(auto) f2()
{
  int x = 0;
  return (x); // decltype((x)) is int&, so f2 returns int&  很tricky
}
```

#	C++11 new features

## using xx = yyyy 来替代
```
using CONTAINER_TYPE  = std::unordered_map<
        boost::asio::ip::udp::endpoint, std::shared_ptr<Client>,
        std::size_t(*)(const boost::asio::ip::udp::endpoint&)>;

CONTAINER_TYPE sessions_;
```

等同于 typedef
```
using SEND_HANDLER = std::function<void (boost::asio::ip::udp::endpoint&, const char *, int)> ;
```

## 新的for 语法
for (auto c:string){} ->c被自动推导为char,而使用for (string::iterator it = string.begin()...)的就是it,是指向char的指针，不一样

```
for (const auto& kv : allTests_) {  //map
    std::cout << kv.first <<  std::endl;
}

for_each() {}
```


## 新的转换函数
C++11 Conversion func
std::to_string
std::stoi 

## misc
std::remove_reference


## Initialize list
Pair
Operator < comp first then second

## Tuples
用于组合多个元素，可以替代pair或者需要更多参数的场合
```
<tuple>
class Name { ... }; 
class Address { … }; 
class Date { … };
std::tuple<Name, Address, Date>
employeeInfo(unsigned employeeID);// function to return

tuple_size,tuple_element,make_tuple,

通过get函数模版来访问成员
std::tuple<int,char> mytuple (10,'a');
std::get<0>(mytuple) = 20;
std::tie(empName, empAddr, empHDate) = employeeInfo(eid);  // 返回并分别设置3个变量的数值
```

**make_tuple来生成一个tuple**

```
std::tuple<Name, Address, Date>
employeeInfo(unsigned employeeID) 
{
  Employee e(findByID(employeeID)); 
  return std::make_tuple(e.name(), e.address(), e.hireDate());
}
```

Reflection用法：？？
std::tuple<int,double> mytuple(1,3);
std::size_t num = std::tuple_size<std::tuple<int, double>>::value;

## fixed size array
替代boost::array
```
std::array<int, 5> arr;  // create array
int *pElements = arr.data();  // get pointer to elements
no insert,push_back,erase,clear
arrays are aggregates,默认初始化为built-in type->0
```

## std::regex
```
std::regex capStartRegex("[A-Z][[:alnum:]]*");  // alnum substr. 
// starting with a 
// capital letter
std::regex SSNRegex(R"(\d{3}-\d{2}-\d{4})");  // looks like a SSN 
// (ddd-dd-dddd)

regex_match, regex_search,regex_replace
```

## Library futures
```
static_assert
static_assert(CHAR_BIT == 8, L"chars don't have 8 bits \u2620");  // wide string

class Widget { 
public:
  explicit Widget(int i);  // C++98 and C++0x
  //…
  explicit operator std::string() const;  // C++0x only
};
```

## 完美转发 perfect_forward
我们需要一种方法能按照参数原来的类型转发到另一个函数中，这才完美，我们称之为完美转发。
std::forward就可以保存参数的左值或右值特性。
http://blog.csdn.net/wangshubo1989/article/details/50485951

不但转发对象，而且转发原有的类型，左值还是右值, 这意味着我们要用universal reference来作为形式参数。

## 可变模板参数 variadic templates
参考深入理解C++11 by IBM,p103
引用折叠

```
void print() {} // 必须需要这个空参数的函数，因为args最后为空
template <typename T, typename...Args>
void print(const T& firstArg, const Args& ...args) {
// 用于萃取第一个参数出来
    cout << firstArg << endl;
    print(args...); // ...在后面表示可变个数的变量
};
```  



##	result_of all_of
TODO
The reason std::result_of<f(int)> does not work is because f is not a type --it is an instance of a function type.
```
int foo(int x, double y) {
    cout <<"foo\n";
    return 0;
}
```
//std::result_of<foo(int,double)>::type result_type; //error
foo并不是一个type,而是一个函数的instance.

std::all_of（begin,end,pred）是否都满足要求



## initializer list
TODO
一致性初始化和初值列
无法窄化转换
```
ctor(实参个数／和初始值列) 同时存在的时候，优先匹配后者
ctor(int,int)  / ctor(std::initializer_list<int>)

class P {
    public:
        P(int a, int b) {}
        explicit P(int a, int b, int c) {}
    };

    void test_initializer_list() {
        P p1{1,2};  // ok
        P p2(1,2);  // ok
        P w1(1,2,3);  // ok
        P w2{1,2,3};  // ok ctor
        P w3 = {1,2,3};  // error: chosen constructor is explicit in copy-initialization
}
```

Class xxx = {} 这种看上去也是copy ctor,但属于比较特殊的copy-initialization, ->P w3 = w(1,2,3); compiler会尝试在右侧做转型（conversion），由于明确explicit ctor(xxx)，所以不允许转型

String x="abc",这种转换并没有copy-ctor,而是等同于direct initialization,参考cpp03 

##	User defined literal
TODO
https://www.cnblogs.com/tocy/p/cpp11-user-defined-literal.html
通过重载””后面加上字符串得到，例如
可以在switchi 使用”*”_hash
```
typedef std::uint64_t hash_t;
constexpr hash_t prime = 0x100000001B3ull;
constexpr hash_t basis = 0xCBF29CE484222325ull;
hash_t hash_(char const* str)
{
    hash_t ret{basis};

    while(*str){
        ret ^= *str;
        ret *= prime;
        str++;
    }

    return ret;
}
constexpr hash_t hash_compile_time(char const* str, hash_t last_value = basis)
{
    return *str ? hash_compile_time(str+1, (*str ^ last_value) * prime) : last_value;
}
constexpr unsigned long long operator "" _hash(char const* p, size_t)
{
    return hash_compile_time(p);
}
```

##	Lambda
匿名函数/anonymous function, functional programming, closure,has its status
形式：
```
[capture](parameters)mutable->return-type{statement}
```

嵌在另一个函数内部:
```
data_cond.wait(lk, [this]{return !data_queue.empty(); });
std::for_each(v.begin(), v.end(), [](int a){std::cout <<a<<" "; });
```

或者临时声明: 用auto更好
```
std::function<void(vector<string> &, string &, int, int)> 
getAllPatterns = [&getAllPatterns,this,cosize](vector<string> &comb, string &number, int index, int length) {
    if (index == length) {
        comb.push_back(number);
        return;
    }
    for (size_t i = 0; i < cosize; i++) {            
        number[index] = colors_[i];
        getAllPatterns(comb, number, index + 1, length);
    }
};
```

variadic template, 用来减少函数的参数
```
template<typename Func, typename ... Args>
auto curry(Func func, Args...args) {
    return [=](auto ...lastParam) {
        //cout << "bind " << lastParam << endl;
        return func(args...,lastParam...); // args 先绑定了第一次预设的参数，然后返回的这个lambda还可以再接受一个参数
    };
};

int areaOfRectangle(int length, int width) {
    return length*width;
}

void test_curry() {
    int test_a;
    auto comp = [&]() {
        cout <<test_a<<endl;
    };

    auto findMax= [](auto &x,auto &y) {
        return x>y?x:y;
    };
    auto length5 = curry(areaOfRectangle, 5);  //类似bind的作用
    for (int i=0;i<=5;i++) {
        cout << "length5("<<i<<") =" << length5(i) << endl;
    }
}
```

**必须指明capture mode,否则报错**

```
//error: variable 'test_a' cannot be implicitly captured in a lambda with no capture-default specified
int test_a;
auto comp = []() {
    cout <<test_a<<endl;
};
```
使用initialization captures,参考 effective modern C++ item32
默认情况下lambda总是一个const函数，mutable可以取消其常量性
#	String
## 实现
主要有SSO 短字符优化,COW 写时拷贝(需要referencecount支持), eager copy(cow初级版本),标准并没有规定string必须连续保存。

Clang(24bytes), vc(40/48) ->sso; SSO 小字符串优化
g++(4/8)->cow; COW 会使用一个引用计数，对多线程不友好，可以参考EFC
sgi stl(12/24) eager copy

是否使用了pool? 对多线程支持如何? - 
几个不同平台的string 的实现,
http://www.cnblogs.com/Solstice/archive/2012/03/17/2403335.html

```
char buf[] = "hello";
size_t t = sizeof(buf);  // 6
size_t l = strlen(buf);  // 5
string str(buf);
size_t len = str.length();
char c1 = str[5];   // '\0'
char buf[]="hello", size(buf)=6,strlen(buf)=5, string的行为和这个类似,string[5] == '\0'
```

## startwith

static wstring_t wstrPrefix = TXT("garena_talk_app_link");        
if (boost::algorithm::starts_with(wstrUrl, wstrPrefix))

## replace
boost的实现:
```
#include <boost/algorithm/string/replace.hpp>

// in place
std::string in_place = "blah#blah";
boost::replace_all(in_place, "#", "@");

// copy
const std::string input = "blah#blah";
std::string output = boost::replace_all_copy(input, "#", "@");
```

### 替换单个字符:
 std::string s = "example string";
 std::replace( s.begin(), s.end(), 'x', 'y'); // replace all 'x' to 'y'

## 	find_last_of
- Searches the string for the last character that matches any of the characters specified in its arguments.
找到匹配任意一个字符的位置.
Find_first_not_of 可用于去掉leading space，找到第一个非空格的字符
##  isdigit(char)
是否0-9
## erase 
从string中删除一个或多个字符

#	function/bind
## 原理
要实现一个bind需要解决两个问题，第一个是保存可调用对象及其形参，第二个是如何实现调用。下面来分析如何解决这两个问题。

根据占位符来选择合适的实参
这个地方比较关键，因为tuple中可能含有占位符，我们展开tuple时，如果发现某个元素类型为占位符，则从调用的实参生成的tuple中取出一个实参，用来作为变参的一个参数；当某个类型不为占位符时，则直接从绑定时生成的形参tuple中取出参数，用来作为变参的一个参数。最终tuple被展开为一个变参列表，这时，这个列表中没有占位符了，全是实参，就可以实现调用了。这里还有一个细节要注意，替换占位符的时候，如何从tuple中选择合适的参数呢，因为替换的时候要根据顺序来选择。这里是通过占位符的模板参数I来选择，因为占位符place_holder<I>的实例_1实际上place_holder<1>, 占位符实例_2实际上是palce_holder<2>,我们是可以根据占位符的模板参数来获取其顺序的。

参考<函数 bind 实现原理初探>
https://my.oschina.net/zhcosin/blog/205426
```
template<typename RT, typename T1, typename T2>
class bind
{
 typedef RT (*fun_type)(T1, T2);
 fun_type f;
 arg_list<T1, T2> para_list;

public:
 bind(fun_type fun, T1 p1, T2 p2) : f(fun), para_list(p1, p2) {}
 bind(fun_type fun, const place_holder<1>& ph1, T2 p2) : f(fun), para_list(ph1, p2) {}
 bind(fun_type fun, T1 p1, const place_holder<2>& ph2) : f(fun), para_list(p1, ph2) {}
 bind(fun_type fun, const place_holder<1>& ph1, const place_holder<2>& ph2) : f(fun), para_list(ph1, ph2) {}
```

##	函数作为模版参数
```
template<typename F>
class FunctionWrapper {
    F f;
public:    
    FunctionWrapper(F _f) {
        f=_f;
    }
    void operator()() {
        f();
    }
};

int foo(int x, double y) {
    cout <<"foo\n";
    return 0;
}
```
FunctionWrapper<foo> f(foo);//error，这个无论如何都不可以，说foo不是type

```
template <typename F>
void doOperation(F f)
{
  f();
}
doOperation(bind(foo, 5, 5.0)); //ok

class FunctionWrapper {
public:    
    template<typename F>
    FunctionWrapper(F f) {        
    }
};
auto f=bind(foo, 5, 5.0);
FunctionWrapper functor(f);
```

**结论**
函数不可以作为类的模版参数，但可以作为函数的模版参数?
可以通过这个办法将函数的实例保存下来。参考advancethreadpool


 

## 概述
为什么使用bind? 通常都是从这个例子入手，那些遍历container的程序，其中需要调用pred函数的情况，而STL中往往没有合适的pred,需要用bind来合成一个新的.参考STL extension TR1 chapter10. <c++ primer>p491,先看基本的C++ functor的实现：首先是函数指针不能被内联，导致效率不高:
```
template < typename Type, bool (*Comp)(const Type&, const Type&)>
 const Type& min( const Type *p, int size, Comp comp )
{
  int minIndex = 0;
  for ( int ix = 1; ix < size; ++ix )
    if ( Comp( p[ ix ], p[ minIndex ] ))
      minIndex = ix;
  return p[ minIndex ];
}
```

在这里Comp是一个函数指针。修改为typename Comp
函数对象是一个类，它重载了函数操作符operator();而且可以拥有额外的任意数据作为缓冲.
(AI(a,b)好像和构造函数类似?)预定义的函数对象，即用一个类封装了函数指针.


## 传统的STL:functor: 现在应该已被淘汰，不太常见

目的是，把各种不同类型的函数指针(成员函数指针)转换为同一种对象—functor，以解决couple耦合问题
unary_function<x,x>, Function Adapters
bind1st和bind2nd函数用于将一个二元算子（binary functor，bf）转换成一元算子（unary functor，uf）。为了达到这个目的，它们需要两个参数：要转换的bf和一个值（v）。(boost有没有这个问题？)

eg:
//这就是一个最普通的functor,之所以从binary_function继承是为了bind能够调用.
```
struct printx: public binary_function<int, int, int >
{
  int operator()(int a, int b)const
  {
     cout<<a+b<<endl;
    return a+b;
  }
};

int main()
{
    vector<int> my;
    my.push_back(0);
    my.push_back(1);
    my.push_back(2);
    copy(my.begin(), my.end(), ostream_iterator<int>(cout, " "));
    cout<<"\n-----"<<endl;
    for_each(my.begin(),my.end(), bind2nd(printx() , 3) );
    return 0;
}
```

note:将printx这个二元参数的函数转换为1元参数，bind第二个参数的意思,用得不多,要求是必须从binary_function继承

Bind用途，将任意个参数的成员函数构造成一个function<>对象(functor)，传统的STL::bind只能够绑定1个或者2个参数。结论：传统的STL::functor和bind用处不多了，最主要是boost中的用法，搞清楚boost::bind是怎么转换的.

## find_if和使用predictor
```
#include <algorithm>
#include <string>
#include <list>
#include <iostream>

using namespace std;

struct SServerInfo {
public:
  std::string         ipaddr_;
  uint32_t            port_;
  bool                lock_status_;
  uint32_t            op_;
  std::string         status_;
  std::string         hostname_;
  std::string         name_;
  std::string         description_;
  uint32_t            id_;
  SServerInfo() : ipaddr_(""), port_(0), lock_status_(false), op_(0), status_(""),
      hostname_(""), name_(""), description_(""), id_(0) {}
  SServerInfo(const std::string& ipaddr, uint32_t port, bool lock_status, uint32_t op,
    const std::string& status, const std::string& hostname, const std::string& name,
    const std::string& desp, uint32_t id=0):
    ipaddr_(ipaddr), port_(port), lock_status_(lock_status), op_(op), status_(status),
    hostname_(hostname), name_(name), description_(desp), id_(id) {}
};

struct ServerCompare : public std::binary_function<SServerInfo*, SServerInfo*, bool> {
  bool operator() (SServerInfo *a, SServerInfo *b) const {
    return (a->ipaddr_ == b->ipaddr_) && ( a->port_ == b->port_);
  }
};

std::list<SServerInfo*> g_lst;

void init_serverlist() {
  for (int i = 0; i < 10; i++) {
    SServerInfo *p_serverinfo = new SServerInfo();
        p_serverinfo->port_ = i;
    g_lst.push_back(p_serverinfo);
  }
}

void find_server(SServerInfo *ps) {
  std::list<SServerInfo*>::iterator iter;
  iter = find_if(g_lst.begin(), g_lst.end(), bind2nd(ServerCompare(),ps));
  if (iter != g_lst.end()) {
    std::cout << "Found" << std::endl;
  }  else {
    std::cout << "Not Found" << std::endl;
  }
}

int main() {
  init_serverlist();
  SServerInfo theone;
  theone.port_ = 5;
  find_server(&theone);
}

不再需要ptr_fun, mem_fun, mem_fun_ref, std::mem_fn
```

## 利用function作为回调函数使用
```
#include <tr1/functional>
#include <iostream>

void print_num(int i)
{
    std::cout << i << '\n';
}

typedef std::tr1::function<void(int)> CALLBACK;

int main()
{
  CALLBACK cb = print_num;
  cb(5);
}
```

C++11:
```
using SEND_HANDLER = std::function<void (boost::asio::ip::udp::endpoint&, const char *, int)> ;

std::bind(&DARKNET::UdpServer::sendTo, udpServer_, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)
```

注意placeholders:_1不要和boost里面的混用，否则会编译问题

## 使用bind和function 来组织程序 chenshuo
http://blog.csdn.net/Solstice/archive/2008/10/13/3066268.aspx

尽管通过回调来绑定两个模块，也需要知道回调函数的具体定义，但是bind可以帮助忽略掉一些参数

thread库，但意义不大...

用bind/function 将下层的通信库和上层的网络协议库装配到一块

http://blog.csdn.net/Solstice/archive/2008/10/13/3066268.aspx另一种模块关系设计:以boost::function和boost:bind取代虚函数
```
boost::function<void(int)> f2; // int 参数，无返回值
f2 = boost::bind(&Foo::methodInt, &foo, _1);
f2(53); // 调用 foo.methodInt(53);
```

前面的EchoService可算是依赖注入的例子，EchoService需要一个什么东西来发送消息，它对这个“东西”的要求只是函数原型满足SendMessageCallback，而并不关系数据到底发到网络上还是发到控制台。在正常使用的时候，数据应该发给网络，而在做单元测试的时候，数据应该发给某个DataSink。

按照面向对象的思路，先写一个AbstractDataSink interface，包含sendMessage()这个虚函数，然后派生出两个classes：NetDataSink和MockDataSink，前面那个干活用，后面那个单元测试用。EchoService的构造函数应该以AbstractDataSink*为参数，这样就实现了所谓的接口与实现分离。

我认为这么做纯粹是脱了裤子放屁，直接传入一个SendMessageCallback对象就能解决问题。在单元测试的时候，可以boost::bind()到MockServer上，或某个全局函数上，完全不用继承和虚函数，也不会影响现有的设计。”


## Function Adapters for Member Functions
```
class Person {
private:
    std::string name;
public:
    Person(string str){name=str;}
    void print()const{    std::cout << name << std::endl;}
    void printWithPrefix (std::string prefix)const{   std::cout << prefix << name << std::endl;}
    void operator()(Person &lhs) const {std::cout << lhs.name << std::endl;}
};


void test_memptr()
{
  std::vector<Person> coll;
  using std::for_each;
  using std::bind2nd;
  using std::mem_fun_ref;

  Person item("first");
  coll.push_back(item);
  //call member function print() for each element
  for_each (coll.begin(), coll.end(),mem_fun_ref(&Person::print));

  //call member function printWithPrefix() for each element
  //-"person: " is passed as an argument to the member function
  for_each (coll.begin(), coll.end(),bind2nd (mem_fun_ref &Person::printWithPrefix),"person: "));
}
```

这是一个典型的mem_fun的例子，然而还可以这样写:
```
struct printx
{
  void operator()(Person &lhs) const
  {
    std::cout <<"lhs.name"<< std::endl;
  }
};
TODO
for_each (coll.begin(), coll.end(),printx());
```

也可以这样写
```
Person item(“first”);
for_each (coll.begin(), coll.end(),item);
```

却不能直接写for_each (coll.begin(), coll.end(),printx);或者Person

究其原因，因为for_each 的第三个参数是一个实例，变量,而前面的template,可以填类型,Person
```
template<class _InIt,	class _Fn1> inline
	_Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func)
	{	// perform function for each element
	
	for (; _ChkFirst != _ChkLast; ++_ChkFirst)
	_Func(*_ChkFirst);
	return (_Func);
	}

```

MCD中有非常复杂的functor实现，先看看STL中提供的,Mem_fun的用途是把对static/全局函数的调用匹配到成员函数的调用上，显然，对成员函数的调用需要一个this 指针，因此，要求原本的全局函数的参数必须有一个(class Obj*)，这样才能把转换成Obj->func的形式

看看mem_fun的实现(STL tutorial 8.2.2)
```
// TEMPLATE CLASS mem_fun_t
template<class _Result,class _Ty>
class mem_fun_t: public unary_function<_Ty *, _Result>
{	// functor adapter (*p->*pfunc)(), non-const *pfunc
public:
explicit mem_fun_t(_Result (_Ty::*_Pm)()): _Pmemfun(_Pm)
{	// construct from pointer		}
_Result operator()(_Ty *_Pleft) const
{	// call function
  return ((_Pleft->*_Pmemfun)());
}

private:
  _Result (_Ty::*_Pmemfun)();	// the member function pointer
};
```

可见
缺点,mem_fun不支持1个参数,原因是for_each不支持一个参数的函数调用

成员函数转为普通函数的模板


参考: http://veniriver.blog.sohu.com/124609632.html
```
Effective C++3
GameLevel currentLevel;
...
EvilBadGuy ebg2(                                   // character using a
  std::tr1::bind(&GameLevel::health,               // health calculation
          currentLevel,                            // member function;
          _1)                                      // see below for details
);
```
C++11中是否还是用这个函数?


#	IO stream

IO stream类是不可复制的，假如一个stream读入了一段内容，那么当执行copy操作的时候，这段内容是否该被复制？最好的做法就是声明为不可copy ctor,assignment

## 文件是否存在
```
#include <boost/filesystem.hpp>
if ( !boost::filesystem::exists( "myfile.txt" ) )
{
  std::cout << "Can't find my file!" << std::endl;
}

```
删除目录/文件

```
console 输出,设置填充字符以及宽度
cout.fill('.'); std::cout << setw(5) << left << iter.first << "\t" << iter.second << std::endl;
```

## 写入文件

## 读入文件

```
读入二进制文件:
 std::ifstream is(fileName, std::ios::binary);
 while (is.read(buf, sizeof(buf)).gcount() > 0)
 {
   content.append(buf, is.gcount());
 }
 is.close();
```

有好几种做法，以std::getline为例

```
#include "iostream"
#include "fstream"
#include "string"
using namespace std;
int main()
{
 string name,line;
 cin>>name;
 ifstream fp(name.c_str());

 while (!fp.eof())
 {
  istream &ret = std::getline(fp,line);
  if (ret) {
    int x = 1;
  }
  cout<<line<<endl;
 }
 return 0;
}
```

这段代码有人认为是错的，应该用fp.good()或者fail()来检测in的状态，原因是未读取之前根本不知道in的状态.
http://stackoverflow.com/questions/5605125/why-is-iostreameof-inside-a-loop-condition-considered-wrong

```
Because iostream::eof will only be set after reading the end of the stream. It does not indicate, that the next read will be the end of the stream.Consider this (and assume then next read will be at the end of the stream):
while(!inStream.eof()){
int data;
// yay, not end of stream yet, now read ...
  inStream >> data;
// oh crap, now we read the end and *only* now the eof bit will be set (as well as the fail bit)
// do stuff with (now uninitialized) data
}
```
实际上下面这段代码才是比较理想的

```
#include <iostream>
#include <string>
#include <fstream>

usingnamespace std;

int main(int argc, char** argv)
{
    ifstream ifs("test.txt");

string str;
while (getline(ifs, str))
    {
        cout << str << endl;
    }

return0;
}
```

因为eofbit,goodbit falsebit都是要读了之后才设置的，没有读就没有结果.

还有一种使用ifstream的成员函数getline逐行读取，并在打开前检查文件,参考
http://blog.csdn.net/kingstar158/article/details/6859379

```
istream& getline (char* s, streamsize n );
istream& getline (char* s, streamsize n, char delim );

char buffer[256];
std::string name;
std::cin >> name;
std::ifstream in(name.c_str());
if (! in.is_open()) {
  std::cout << "Error opening file"; exit (1); 
}
while (in.getline(buffer,100))  {    
  std::cout << buffer << std::endl;
}
```

然而这个方法有个缺陷，如果buffer太小不能容纳一行的话，他就返回false bit.只能用下面这种坑爹的做法来调整每次读取得数据大小.in.clear()是将stream清除errorbit.
http://stackoverflow.com/questions/20645396/how-to-safely-read-a-line-from-an-stdistream

```
while (!in.eof())  {
    int base = 0;
    int size = 15;
    int gcount = 0;
    do {
      in.clear();      
      readline(in, &buffer[base], size);
      gcount = in.gcount();
      base  += gcount;
      size += gcount;
      failflag = in.fail();
    } while (failflag && gcount);

    if (!failflag) {
      std::cout << buffer << std::endl;
    }    
  }
这种方式<<是逐个词读取，并且会丢弃之间的空格
//读取方式: 逐词读取, 词之间用空格区分
//read data from the file, Word By Word
//when used in this manner, we'll get space-delimited bits of text from the file
//but all of the whitespace that separated words (including newlines) was lost. 
void ReadDataFromFileWBW()
{
  ifstream fin("data.txt");  
  string s;  
  while( fin >> s ) 
  {    
      cout << "Read from file: " << s << endl;  
  }
}
```

C++文件读写详解（ofstream,ifstream,fstream）http://blog.csdn.net/kingstar158/article/details/6859379

一个简单的:
```
std::string name;	
std::string s;
std::cout << "please input filename";
std::cin >> name;
std::ifstream in(name.c_str());
if (!in.is_open()) {
  std::cout << "Error opening file"; exit(1);
}
while (in >> s)  {s
  std::cout << s << std::endl;
}
in.close();
```

#	container/iterator
## 容器概述

非标准容器 valarray,stack,queue, priority_queue

其中valarray用于数值计算，例如数组相乘,没有push等操作；是否支持迭代?

对于container adaptor的解释:

`stack`, `queue` and `priority_queue` are implemented as container adaptors. Container adaptors are not full container classes, but classes that provide a specific interface relying on an object of one of the container classes (such as deque or list) to handle the elements. The underlying container is encapsulated in such a way that its elements are accessed by the members of the container adaptor independently of the underlying container class used.

stack 没有迭代器
queue 没有迭代器

map 和 unordered_map的迭代器，重载了operator->(),令其返回一个指针，first指向map的key，second指向value

list iterator 24 bytes
string 40bytes?

构造函数，可以支持initializer list方式，如vector<int> coll = {1,2,3,4,5}

不是thread safe,一般均不检查 pop_back(), front() 元素是否存在,一般不抛出异常，除了vector::at() (range-error)
push_back,insert,emplace一般不抛出异常（只要element copy/move不抛出异常）
push_back 一般调用copyctor

多数提供rbegin(reverse iterator) 和 cbegin(const iterator), 特例？
for (auto xx: container) 方式遍历的时候，采用的是值拷贝方式，注意使用auto &iter : container
++iter, 这样会省掉一次临时变量保存iter++的值。

unordered_map.的iterator是`pair<const key, value>`, 即key是不可修改的
非序列式容器没有push_back,即hashmap等没有后端插入这种概念
unordered_map的遍历顺序取决于hashing函数，或者hashtable的实现

## 时间复杂度
可以参考**tech_interview.md**
insert 和 erase的复杂度
vector insert, O(N)
find, find_if,查找 O(N)
如果是有序容器, 二分查找会是LogN

容器种类
Single associate container key=value ->set
Pair associate container value type =  pair<const key,value>
还分为multiple associate和unique associate 
从key来分有hashed associate container和sorted associate container

## vector
移除某个值需要 vec.erase（remove(xxx)）结合
不要使用&vec.begin()取地址这种做法，这个取的是iterator的地址，也许换了个平台就无效。
vector的 push_back和insert都会涉及元素的拷贝

clang 中的内存增长因子为2, 
```
cout << capacity()
0 after:1
1 after:2
2 after:4
4 after:4
4 after:8
8 after:8
8 after:8
8 after:8
8 after:16
16 after:16
```
使用shrink_to_fit()来缩减capacity,但是不保证。使用swap更好，但是意义也不大。
**C++11	支持move后resize会高效很多**
如果支持了move会高效很多，由于插入临时对象的缘故?

`c1<c2` 按照lexicographical_compare逐个元素比较，如果相等就再比较下一个，直到不想等为止。

特例vector<bool>, 使用了bit来保存，所以实际长度比实际元素少，通过一个proxy实现。
如果需要固定大小的bitfield可以使用bitset


## deque
deque 随机访问虽然是O(1), 但是常数因子比vector大很多。
deque不是C兼容的连续内存, 内存布局上是分成几个大的block，互相之间再通过指针串在一起。

## vector ,deque ,list 比较
参考herb sutter`<more exceptional C++>`，vector是完全连续内存,如果需要在首部插入元素，deque 更好, deque不是内存连续的，随机访问比不上vector,

deque与vector性能比较
1.在插入大量的小数据时，两者差别不大，deque快
2.插入大量的复杂数据呢？
3.随机访问肯定是vector更快


## 遍历容器  ITERATOR
```
// generate game list
typedef boost::unordered_map<int, Gift> HASH;
BOOST_FOREACH(HASH::value_type &pair, m_gifts)
{
    Gift &g = pair.second;
    if (g.m_class == GIFT_CLASS_GAME_GIFT)
    {
        m_listGameGifts.push_back(g);
    }
}
```

c++17



## vector<string> resize 是否会复制原有字符串
参考string 的实现。
先看普通的push_back,没有resize，
vec.push_back("abc")  // sso 实现的string， 保存的是短字符串
vec需要用memmove 把string(temporary object) 的内容复制到vec中 (move constructor)
vec.push_back("abcxxxdf…..超过了sso的buffer大小")  // 同样是move constructor，他只需要把string的buf指针赋值给vec的element即可。
可以通过查看vec的元素 c_str()所指向的实际buffer来验证。

resize也是同样道理。

##	push 传值还是传引用
原题没有具体描述，说的不是很清楚
push_back 使用的是copy-ctor，照理使用传引用比较快，为何cpp concurrency in action中使用传值(需要调用一次copy ctor)
传引用需要ctor+copy-ctor;
pop需要一次copy-ctor

定义
```
push_back(const_reference __x)
construct(_Up* __p, _Args&&... __args)
{
    ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);
}
```
这里调用的是placement new,在给定的内存上调用Up(args=const A&)即copy ctor
所以push_back一共调用了一次copy ctor, 另外在容器上new了一个空间。(必须的步骤)

## insert adapter
## priority queue 优先队列
A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction.
是完全二叉树结构

popup 是常数时间，插入是O(LogN)
User defined comp,参见leetcode 378，使用了tuple, comp
```
using mytuple=tuple<int,int,int>;
auto comp = [](mytuple &lhs,mytuple&rhs){
    return std::get<0>(lhs) > std::get<0>(rhs);
};

std::priority_queue<mytuple,std::vector<mytuple>,decltype(comp) >q(comp);

//class Compare = std::less<typename Container::value_type>> q;
int n=matrix.size();
// push first column
for (int row=0;row<n;row++) {
    auto el = std::make_tuple(matrix[row][0],row,0);
    q.push(el);
}
int v,row,col;
for (int j=1;j<k;j++) {
    std::tie(v, row, col) = q.top();
    q.pop();
    if (col+1==n) {
        continue;
    } else {
        q.push(std::make_tuple(matrix[row][col+1],row,col+1));
    }
}

std::tie(v, row, col) = q.top();
return v;
```
需要用decltype(comp)来声明模版里comp类型，构造函数里带comp作为参数
也可以用tie来获取tuple的数值，以上用了get<0>



## unordered_map

### 当key是一个pointer的时候
注意每插入一个新的元素需要新建一个key,对于指针来说，就是copy 指针本身而已
```
#include <string.h>
#include <tr1/unordered_map>
#include <iostream>

using namespace std::tr1;

struct mykey
{
    int x;
};

struct myeq
{
   bool operator()(const mykey *s1, const mykey* s2) const
   {
     return s1->x==s2->x;
   }
};

struct myhash {
  size_t operator()(const mykey* k) const {
    return k->x;
  }
};

int main()
{
   unordered_map<mykey *, int, myhash, myeq> months;


   char buf[64];
   mykey key;
   for (int j=0;j<20;j++) {      
      key.x=j;
      months[&key]=j;
   }

   unordered_map<mykey *, int, myhash, myeq>::iterator iter;
   for (iter = months.begin();iter!=months.end();iter++)
   {
     std::cout<<iter->first->x<<","<<iter->second<<std::endl;
   }
}
```

### 不正确的key
```
namespace wrongkey {
//    struct eqstr
//    {
//        bool operator()(const char* s1, const char* s2) const
//        {
//            return strcmp(s1, s2) == 0;
//        }
//    };

    using MonthContainer = std::unordered_map<const char*, int>;
    //using MonthContainer = std::unordered_map<const char*, int, hash<const char*>, eqstr>;


    void iterate(MonthContainer &cont) {
        auto &&iter = cont.begin();
        for (;iter!=cont.end();++iter) {
            cout << iter->first << ":" << iter->second <<endl;
        }
    }

    void tempBuf(MonthContainer &cont) {
        char buf[64];
        for (int j=0;j<20;j++) {
            sprintf(buf,"%s%d","key",j);
            cout<<buf<<std::endl;
            cont[buf]=j;   //~~~~~~~~~~~同一个buf，所以效果相当于在这个循环里面直接把hash map的key修改了
        }
    }

    void staticBuf(MonthContainer &months) {
        months["january"] = 31;// 保存在静态或全局内存，不会被释放
        months["february"] = 28;
        months["march"] = 31;
        months["april"] = 30;
        months["may"] = 31;
        months["june"] = 30;
        months["july"] = 31;
        months["august"] = 31;
        months["september"] = 30;
        months["october"] = 31;
        months["november"] = 30;
        months["december"] = 31;
    }
    void test() {
        MonthContainer months;
        tempBuf(months);
        staticBuf(months);
        iterate(months);
    }
}
```

原因: hashmap 会在bucket里保存key和value的一份copy，然而代码中key是一个char *，因此map只会复制该指针的值，而不是指向的内容。tmpBuf中把它指向了一个栈上的临时变量，而且每次都是修改的是同一份key。当退出tmpBuf后，这个地址就失效了。
而staticBuf中则会给这些字符分配一个静态的变量。可参考`char *ptr="xxx"`的实现

另一个例子，inplace 修改了map 中的key，但是该item仍然保存在原处
// change key in place
```
namespace changemapitem {
    using ChangeMap = std::multimap<string, int>;

    void iterate(ChangeMap &cont) {
        cout << "=====================================\n";
        for (auto &&iter:cont) {
            cout << iter.first << ":" << iter.second <<endl;
        }
    }

    void test() {
        ChangeMap cmap;
        cmap.insert(std::pair<string,int>("shanghai",100));
        cmap.insert(std::pair<string,int>("guangzhou",90));
        cmap.insert(std::pair<string,int>("shenzhen",95));
        cmap.insert(std::pair<string,int>("xiameng",100));
        cmap.insert(std::pair<string,int>("zhanjiang",100));
        cmap.insert(std::pair<string,int>("beijing",100));
        cmap.insert(std::pair<string,int>("hanzhou",100));
        cmap.insert(std::pair<string,int>("nanjing",100));
        cmap.insert(std::pair<string,int>("wuhang",100));
        iterate(cmap);

        auto &&ret = cmap.find("guangzhou");
        if (ret != cmap.end() ) {
            const_cast<string&>(ret->first) = "tibet";//强行修改了key
            ret->second = 50;
        }
        iterate(cmap);
    }
}
```

beijing:100
tibet:50  --> 不应在此处, 强制去掉了const 并修改
hanzhou:100
nanjing:100
shanghai:100
shenzhen:95
wuhang:100
xiameng:100
zhanjiang:100



### 自定义unordered_map中的hash
```
class KeyHashOperator
{
public:
    size_t operator()(const boost::asio::ip::udp::endpoint & key) const
    {
        std::ostringstream stream;
        stream << key;
        std::hash<std::string> hasher;
        return hasher(stream.str());
    }
};

Using CONTAINER_TYPE = std::unordered_map<boost::asio::ip::udp::endpoint, std::shared_ptr<Client>, KeyHashOperator>;
```

### 动态指定hash
```
 using container_type = std::unordered_map<ip::udp::endpoint, std::shared_ptr<client>, std::size_t (*)(const ip::udp::endpoint&)>;

/// @brief Return a hash value for the provided endpoint.
static std::size_t get_hash(const ip::udp::endpoint& endpoint)
{
  std::ostringstream stream;
  stream << endpoint;
  std::hash<std::string> hasher;
  return hasher(stream.str());
}
```

初始化
clients_(0, &client_manager::get_hash)
0是什么 -> Minimum number of initial buckets.This is not the number of elements in the container, but the minimum number of slots desired for the internal hash table on construction.初始的bucket数量.

参看c++stl2.0 p390， 使用一个函数指针类型作为模版参数，构造实例时再传递一个具体的hash函数。

### 使用Lambda Hash function
```
#include<unordered_map>
#include<string>

int main() {
    auto my_hash = [](std::string const& foo) {
        return std::hash<std::string>()(foo);
    };
    auto my_eq = [](const std::string&a, const std::string &b) { return a==b;}
    std::unordered_map<std::string, int, decltype(my_hash), decltype(my_eq)> my_map(10, my_hash, my_eq); 
}
```

参考c++stl2.0 p407

###	比较完整的自定义类型例子
参考 miscode-msccp-container-userdefined_hashmap.cpp, 基本上2种方法，通过在外部定一个functor,或者在std ns下面增加一个hash func(), 注意hashfunc,keycomp中均使用const，这可能是因为hash_map中使用了const来作为模板

```
// Created by Rui Zhou on 7/3/18.
// user defined object with hashmap

#include <codech/codech_def.h>
#include <unordered_map>
#include <iostream>


using namespace std;

namespace udhashmap1 {
    class Order {
    public:
        uint64_t orderId_;
    };

    struct OrderEqual {
        bool operator()(const Order&left, const Order&right) const{
            return left.orderId_ == right.orderId_;
        }
    };

    struct OrderHash {
        size_t operator()(const Order &order) const {
            std::hash<uint64_t> hasher;
            return hasher(order.orderId_);
        }
    };

    using OrderContainer = std::unordered_map<Order, int, OrderHash, OrderEqual>;
    //using OrderContainer = std::unordered_map<Order, int>; // error, don't know how hash func
    //using OrderContainer = std::unordered_map<Order, int, OrderHash>; // error, don't know equal to

    // C++ 17 iterate
    void iterate(OrderContainer &cont) {
        for (const auto & [ key, value ] : cont) {
            cout << key.orderId_ << ": " << value << endl;
        }
    }
    void testInsert() {
        OrderContainer orders;
        Order order1;
        order1.orderId_ = 1;

        Order order2;
        order1.orderId_ = 2;

        uint64_t price1;
        orders.insert(std::make_pair(order1,price1));
        iterate(orders);
    }
}


namespace udhashmap2 {
    class Order {
    public:
        uint64_t orderId_;
        //  equal to 
        bool operator == (const Order&right) const{
            return this->orderId_ == right.orderId_;
        }
    };
}


namespace std {
    template<>
    struct hash<udhashmap2::Order>
    {
        inline size_t operator()(const udhashmap2::Order& s) const
        {
            return hash<uint64_t>()(s.orderId_);
        }
    };
}



namespace udhashmap2 {

    using OrderContainer = std::unordered_map<Order, int>;

    void iterate(OrderContainer &cont) {
        for (const auto & [ key, value ] : cont) {
            cout << key.orderId_ << ": " << value << endl;
        }
    }
    void testInsert() {
        OrderContainer orders;
        Order order1;
        order1.orderId_ = 1;

        Order order2;
        order1.orderId_ = 2;

        uint64_t price1;
        orders.insert(std::make_pair(order1,price1));
        iterate(orders);
    }
}


DEFINE_CODE_TEST(udhashmap)
{
    udhashmap1::testInsert();

    udhashmap2::testInsert();
}
```

### unordered_set user defined hash,eq
和lambda类似
```
using vt=pair<int,int>;
auto my_hash = [](const vt& foo) {
    return std::hash<int>()((foo.first<<16)^(foo.second));
};
auto my_eq = [](const vt&a, const vt &b) { return a.first==b.first && a.second==b.second;};
std::unordered_set<vt,decltype(my_hash), decltype(my_eq)> visited(0, my_hash, my_eq);
```

###	hash function
#### hash<string>

stl 中已经加入了对string hash的支持
使用了__murmur2_or_cityhash
```
std::size_t h1 = std::hash<std::string>{}("MyString");
std::size_t h2 = std::hash<double>{}(3.14159);
```

const需要匹配
到底是否该用char *作为key? -> 不太好

inset是通过hash得出hash值从而判断insert在哪里
find先通过hash,再调用equal来判断是否是要找的东西
remove->hash,then erase

###	自定义unordered_map
这代码太旧了
```
#include <tr1/unordered_map>  // NOLINT(build/include_order)
/** The Hash parameter for the TtrEventMap unordered-map.  */
typedef struct {
  size_t operator() (const TtrDimensionList &dl) const {
    return dl.hash();
  }
} AggregateKeyHash;

typedef std::tr1::unordered_map<TtrDimensionList, TtruEvent*, AggregateKeyHash> TtruEventMap;
```

具体可以参看定义:
```
template < class Key,                                    // unordered_map::key_type
           class T,                                      // unordered_map::mapped_type
           class Hash = hash<Key>,                       // unordered_map::hasher
           class Pred = equal_to<Key>,                   // unordered_map::key_equal
           class Alloc = allocator< pair<const Key,T>>  // unordered_map::allocator_type
> class unordered_map;
```

###	Set<>
一个自定义的ipaddr (同时保存ipv4和ipv6地址)
对于set,需要定义bool operator < ()
定义2个不同参数的ctor,便以在insert的时候做隐式转化
定义copy ctor,因为push_back和insert会用到

//a struct can store both IPV4 & IPV6 addr
```
typedef struct IpAddr
{
  union {
    uint32_t ipaddr4;
    uint8_t  ipaddr6[16];
  }m_addr;
  int m_version;
public:  
  //ctor
  IpAddr(uint32_t addr4)  {    setAddr4(addr4);      }
  //ctor
  IpAddr(const uint8_t *addr6)  {    setAddr6(addr6);      }

  void setAddr4(uint32_t addr4)  
  {
    m_addr.ipaddr4=addr4;
    m_version=4;  
  }
  void setAddr6(const uint8_t* addr6)  
  {
    m_version=6;
    memcpy(m_addr.ipaddr6,addr6,16);
  }
  /*void getAddr6(uint8_t * addr6)
  {
      memcpy(addr6,m_addr.ipaddr6,16);
}*/
  const uint8_t* getAddr6() const
  {
return m_addr.ipaddr6;
  }
  uint32_t getAddr4() const
  {
    return m_addr.ipaddr4;
  }

  //copy ctor  :for set,vector container insert/push_back
  IpAddr(const IpAddr& addr)
  {
    if (addr.m_version==4)
      setAddr4(addr.m_addr.ipaddr4);
    else
       setAddr6(addr.m_addr.ipaddr6); //member of union is const?
  }
  int getIpVersion() const {return m_version;}

  //operator, map会使用lessthan
  bool operator < (const IpAddr& ToCompare) const
  {
    if (m_version<ToCompare.getIpVersion())
      return true;
    else if (m_version > ToCompare.getIpVersion())
      return false;

    // version equalivent
    if (m_version==4)
    {
      if (m_addr.ipaddr4< ToCompare.m_addr.ipaddr4)
        return true;
      else if (m_addr.ipaddr4 >= ToCompare.m_addr.ipaddr4)
        return false;
    }
    else {//ipv6
      int result=memcmp(m_addr.ipaddr6,ToCompare.m_addr.ipaddr6,16);
      if (result < 0)
        return true;
      else if (result>=0)
        return false;
    }
  }
}IPADDR;
```

###	map的插入
```
map<string,string>
需要这样container.insert(map<string,string>::value_type(key,value))
```




##	Iterator
[STLHOUJ] p86 和
http://blog.csdn.net/u013011841/article/details/41514313 描述的不支持原生指针作为模板参数的说法似乎不正确，在vs2013和gcc4.3中都可以通过.
http://www.programlife.net/stl-iterator.html

他的原意应该是指无法萃取出int*的int类型，以及其他类型class*，这需要偏特化

是如下这个意思，如果使用原生指针作为iterator,无法通过编译

```
template<class I>
typename I::value_type func(I ite)//这里I是MyIter, 返回类型是MyIter<T>里面T的类型，也就是int,有了typename和value_type，我们可以让返回值是任何类型都可以  
{
	return *ite; //*ite指向的是int类型，根据T& operator*()const决定返回的类型  
}

int *ite2 = new int(8);	
std::cout << func(ite2) << endl;

使用class type的iterator是可以的
MyIter<int> ite(new int(8));
std::cout << func(ite) << endl;
```


迭代器基本框架
按照约定，迭代器需要定义5个内嵌类型：iterator_category、value_type、difference_type、pointer、reference

### stream_iterator
用来反转一个字符串
```
string sentence = "abc is a word very hard?";
list<string> lst;
stringstream ss(sentence);
copy(istream_iterator<string>(ss), istream_iterator<string>(), front_inserter(lst));
copy(lst.begin(), lst.end(),ostream_iterator<string>(cout, " "));
```

### istreambuf_iterator
从stream buffer中读入
```
count(istreambuf_iterator<char>(in),istreambuf_iterator<char>(),'\n')
```

### advance/distance
往前移动forward iterator
```
template<class _Myvec>
	class _Vector_iterator
		: public _Vector_const_iterator<_Myvec>
	{	// iterator for mutable vector
public:
	typedef _Vector_iterator<_Myvec> _Myiter;
	typedef _Vector_const_iterator<_Myvec> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Myvec::value_type value_type;
	typedef typename _Myvec::difference_type difference_type;
	typedef typename _Myvec::pointer pointer;
	typedef typename _Myvec::reference reference;Vector_iterator的理解

vc中的定义,可以看到这个类只要通过萃取vector中的类型来构造iterator
_Myiter& operator++()
{	// preincrement
++*(_Mybase *)this;
return (*this);
}
```

可以猜测 vector_iterator的起始位置即为实际的vector存储位置,MyBase指向第一个iterator的位置.
如果vector不发生重分配内存，那么Iterator 有效指向实际的存储位置，但是经过sort之后，原先的内存可能已存储其它的东西，这也是一种失效。
如果重新分配了内存，那么iterator指向的内存根本就已经无效了

distance(arr.begin(), iter);
返回iter到begin之间的距离，也就是index

## STL concept
STL 其实是一套严谨的 "concepts" 分类学。这里所谓的 concepts 有其严谨定义，意指「对某种型别的某些条件需求」。满足这些条件之型别，称为该 concept 的一个 model。举个例子，如果我们能够复制型别为 T 之物件，并可以将数值指派给 T 型别的变数身上，那麽型别 T 便符合 Assignable 这一 concept，而 T 便是 Assignable 的一个 model。STL 的六大组件 containers, algorithms, iterators, function objects, allocators, adaptors, 全都是 concepts，实作品如 vector, list, sort(), swap() 等等 templates, ... 全都是 models。

Allocator
没法让deque使用自定义的pool allocator,因为deque是要求连续内存,pool allocator做不到这点




#	算法
std::multiplies 返回乘积
##	copy
std::copy(box.begin(), box.begin()+b,back_inserter(ret));

##	accumulate
累计T的结果
```
template <class InputIterator, class T>
T accumulate (InputIterator first, InputIterator last, T init)
{
  while (first!=last) {
    init = init + *first;  // or: init=binary_op(init,*first) for the binary_op version
    ++first;
  }
  return init;
}
```
注意三个参数,，可以起到foldl,foldr的作用

##	transform
```
transform(in.begin(), in.end(), back_inserter(res), bind(divides<long long>(), prod, placeholders::_1));
```
对区间元素执行操作，再输出到目标位置.
还是没有具体描述清楚 TBD

##	ostream_iterator 打印
copy(res.begin(), res.end(), ostream_iterator<int>(cout,"\n"));
把区间元素复制到ostream_iterator去
ostream_iterator要实现operator = 

https://www.hackerrank.com/challenges/bonetrousle  将vector<int> 转化为string,注意ostream_iterator如何处理
```
int sum = std::accumulate(box.begin(), box.begin()+b,0);
stringstream ss;
copy(box.begin(), box.begin()+b,ostream_iterator<int>(ss, " "));
```

## generate
Generate values for range with function ,利用gen函数为区间内的每个元素生成一个值
```
template <class ForwardIterator, class Generator>
  void generate ( ForwardIterator first, ForwardIterator last, Generator gen )
{
  while (first != last) {
    *first = gen();
    ++first;
  }
}
```

但是得首先有区间，也就是size()>0
仿佛vector接受的size_type是unsigned_type?
```
vector<int64_t> box(k, 1LL); 
int64_t count = 1LL;
std::generate(box.begin(), box.end(), [&count]{return count++;});
```

##	变序型算法
### next_permutation
先对序列进行排序，以升序排列。
获得按升序排列下一个符合次序的组合
实现
找到位于最右侧的一个字符，它比它右侧的某个字符次序小.
这个写起来还挺烦的，可以练习一下
```
_BidIt _Next = _Last;
if (_First == _Last || _First == --_Next)
  return (false);

for (; ; )
{	// find rightmost element not smaller than successor
  _BidIt _Next1 = _Next; // 从end开始相邻两项逐个比较(左>右)，直到遇到一个左侧项比右侧项小，可以得到该数字右侧都是递减顺序的
  if (_DEBUG_LT_PRED(_Pred, *_Next1, *--_Next))
  {	// swap with rightmost element that's not smaller, flip suffix
    _BidIt _Mid = _Last;
    for (; !_DEBUG_LT_PRED(_Pred, *--_Mid, *_Next); ) ;//当遇到这个数字后，开始从最右侧扫描，找到第一个比它大的，交换之，那么此时该数字右侧仍然是递减的,
    _STD iter_swap(_Next, _Mid);
    _STD reverse(_Next1, _Last);// 使用reverse换成递增，即为下一排列顺序
    return (true);
  }

  if (_Next == _First)
  {	// pure ascending, flip all
    _STD reverse(_First, _Last);
    return (false);
  }
}
```

### sort 相关
参考effective STL 32

####	nth_element实现
取中位数，first=最小，mid=中位数，last=最大
然后以中位数分区，TODO 还是不够详细，如何找到n?

#### equal_range
```
template <class ForwardIterator, class T>
  pair<ForwardIterator,ForwardIterator>
    equal_range (ForwardIterator first, ForwardIterator last, const T& val)
{
  ForwardIterator it = std::lower_bound (first,last,val);
  return std::make_pair ( it, std::upper_bound(it,last,val) );
}
```

### sorted-range algorithm 输入有序型算法
**set_intersection()**
必须有序，可以先使用sort(),用于找出两个容器是否存在交集。

**unique** 使所有元素唯一
要求必须有序.在STL中unique函数是一个去重函数， unique的功能是去除相邻的重复元素(只保留一个),其实它并不真正把重复的元素删除，是把重复的元素移到后面去了，然后依然保存到了原数组中，然后 返回去重后最后一个元素的地址，因为unique去除的是相邻的重复元素，所以一般用之前都会要排一下序。

**stable_partition** 需要额外空间

**for_each()**
c++stl2.o en p548

###	其它
R is a range, e is an element, p is a predicate:
all_of  is p true for all e in R?
any_of  is p true for any e in R?
none_of  is p true for no e in R?
find_if_not  find first e in R where p is false
copy_if  copy all e in R where p is true
copy_n  copy first n elements of R
iota  assign all e in R increasing values starting with v
minmax  return pair(minVal, maxVal) for given inputs 
minmax_element return pair(min_element, max_element) for R
min/max/minmax return values.
min_element/max_element/minmax_element return iterators.

R is a range, e is an element, p is a predicate, v is a value:
partition_copy  copy all e in R to 1 of 2 destinations per p(e) 
is_partitioned  is R partitioned per p? 
partition_point  find first e in R where p(e) is false
is_sorted  is R sorted? 
is_sorted_until  find first out-of-order e in R
is_heap  do elements in R form a heap? 
is_heap_until  find first out-of-heap-order e in R
move  like copy, but each e in R is moved 
move_backward like copy_backward, but each e in R is moved

std::move_iterator turns copying algorithms into moves, 
e.g.: 
std::copy_if( std::move_iterator<It>(b), // ≡std::copy_if(b, e, p), 
std::move_iterator<It>(e), // but moves instead of 
p);  // copies

### next_permutation()

next_permutation() changes the order of the elements in [beg,end) according to the next
permutation.
从n个元素中任取r个元素的组合，有n! / (r! * (n-r)!)个
```
#include <algorithm>
#include <vector>
#include <iostream>
#include <iterator>

void permutation(){
  int elements[]={1,2,3,4};
  const size_t N =sizeof(elements)/sizeof(elements[0]);
      std::vector<int> vec(elements, elements + N);
  do{
    std::copy(vec.begin(), vec.end(), std::ostream_iterator<int>(std::cout," "));
    std::cout <<"\n";
  }while(std::next_permutation(vec.begin(), vec.end()));
}
```
注意起始顺序是1,2,3,4，递增的，如果找到更大的排列lexicographicaly greater permutation.，就返回false	

### std::unique
TODO 自己实现一下？
实现也够烦的，就是用两个指针交替前进，替换重复的
```
template<class _FwdIt,class _Pr>inline
_FwdIt _Unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
{// remove each satisfying _Pred with previous
  if(_First != _Last)
  for(_FwdIt _Firstb;(_Firstb = _First),++_First != _Last;)
    if(_Pred(*_Firstb,*_First))
    {// copy down
      for(;++_First != _Last;)
        if(!_Pred(*_Firstb,*_First))
          *++_Firstb = _Move(*_First);
      return(++_Firstb);
    }
  return(_Last);
}
```

### find,find_if,find_if_not
```
template<class InputIterator, class T>   InputIterator 
find (InputIterator first, InputIterator last, const T& val) {   
  while (first!=last) {
    if (*first==val) return first;
    ++first;
  }
  return last; 
}

it = find (myvector.begin(), myvector.end(), 30);
```

如果range是sorted的，建议使用lower_bound,upper_bound,equal_range,binary_search






#	Overview C++11

Overview c++11有些例子(p324)不明白，需要另外看一下。声明，语法格式



21	资源
http://www.tutorialspoint.com/compile_cpp11_online.php


# boost
这块应该考虑去掉了
## 编译
Build boost 1.48 with ms vc2013, 会报告unknown compiler，后面可能还有些Lib不兼容，还是放弃。
boost 1.4.9 和上面有些不同了,使用easy build and install:
Issue the following commands in the shell (don't type $; that represents the shell's prompt):

$ cd path/to/boost_1_49_0
$ ./bootstrap.sh --help
Select your configuration options and invoke ./bootstrap.sh again without the --help option. Unless you have write permission in your system's /usr/local/ directory, you'll probably want to at least use

$ ./bootstrap.sh --prefix=path/to/installation/prefix
to install somewhere else. Also, consider using the --show-libraries and --with-libraries=library-name-list options to limit the long wait you'll experience if you build everything. Finally,

$ ./b2 install
will leave Boost binaries in the lib/ subdirectory of your installation prefix. You will also find a copy of the Boost headers in the include/ subdirectory of the installation prefix, so you can henceforth use that directory as an #include path in place of the Boost root directory.

## Time
取得当前时间
```
static std::string getTimeStamp()
{
    namespace pt = boost::posix_time;
    return pt::to_iso_string(pt::second_clock::local_time());
}
```

## Prebuilt-windows 版本
从boost.org网站上下载相应的msvc prebuilt版本，安装。Visualstudio2013=msvc12.0
在vc里设置include/link路径，并不会自动linkage真实的原因是visualstudio创建的project是32bit,而下载的boost是64bit版本,当设置后路径后编译就会自动link.


## Build 1.57版本
Go to the directory tools\build\.
Run bootstrap.bat
Run b2 install --prefix=PREFIX where PREFIX is the directory where you want Boost.Build to be installed
Add PREFIX\bin to your PATH environment variable.

Boost中的常见话题有:
Shared_ptr如何处理引用计数,如何线程安全
循环引用
Weak_ptr,scope_ptr
定制删除动作

## Boost::thread
Thread_group.create_thread

使用:
```
boost::thread *thrd[EAS_NUM_PIPELINES];
for (int i=0;i<EAS_NUM_PIPELINES;i++)
{
    EAS_Consumer *l_consumer = EAS_Consumer::Create();
    l_consumer->configure();
    thrd[i] = new boost::thread( &EAS_Consumer::loop, l_consumer );    
}

for (int i=0;i<EAS_NUM_PIPELINES;i++)
{
    thrd[i]->join();
}    
```
常规的启动方式是void run()或者通过Functior，
那么能够像surge中采用继承的方式启动吗？(似乎不行)

boost thread 总结:
```
#define BOOST_HAS_THREADS
#include <boost/thread/thread.hpp>

void print()
{
  for (;;)
  {
    int i=1;
  }
}

void start()
{
  boost::thread t1(&print);        
}
int main()
{
  start();
  for (;;)
  {
    sleep(1);
  }
}
```
start函数退出后,thread并没有终结,说明dtor 不会删除线程

可以用functor:struct xxx{operator()(){}};
确实存在c++ concurrency中说的,boost::thread mythread(background_task(5));
 mythread.join();临时对象退出了,线程去需要访问临时对象的数据.

## other
numeric_cast
lexical_cast

# Smart pointer(Shared_ptr,weak_ptr)
## boost::scoped_ptr
无法转移所有权,没有release函数(auto_ptr)
这段代码是错误！所有smartptr都不能从同一个资源构造
```
TestSmartPtr *ptr=new TestSmartPtr;
boost::scoped_ptr<TestSmartPtr> tsp(ptr);
boost::scoped_ptr<TestSmartPtr> tsp2(ptr);
scoped_ptr 指向的对象无法改变ownership，
```
无法复制

智能指针的p运算符
```
scoped_ptr<T> p(new T)
if (p)... 实质会调用 operator()运算符.
typedef T * this_type::*unspecified_bool_type;
operator unspecified_bool_type() const // never throws
{
  return px == 0? 0: &this_type::px;
}
```

用新的指针替换旧的指针
reset(T*p)


### scoped_ptr不支持copy ctor和assignment,无法作为容器的元素

将  
```
void operator==( scoped_ptr const& ) const;
void operator!=( scoped_ptr const& ) const;
```
声明为priate,禁止比较—比较的意图是什么?
```
vector<boost::scoped_ptr<A>> vec;//单纯declare vec可以通过编译
vec.push_back(p);//只有push_back的时候出错:
template<class _Other>
void construct(pointer _Ptr, _Other&& _Val)
{	// construct object at _Ptr with value _Val
::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));
}
```

## 线程安全
线程安全,和内建类型的线程安全级别一样?
shared_ptr本质是线程安全的(我想这里指的是没有static变量)，(这句话不严谨，应该是非线程安全)
当然读写同一个资源时，需要自己控制lock



**weak ptr** 
(2011/08/23)
看看weak_ptr 的用途,弱引用，主要用来打破相互引用这种死循环的。假设N1有一个shared_prt指向了P1,而P1也有一个shared_ptr指向了N1,那么就构成一个死循环,N1和P1永远无法删除.
weak_ptr的不会造成资源计数增加.也没有->和*,因为它不能操作资源,当expired=true的时候,引用计数=0,也可以从lock()上面构造一个shared_ptr

**enable_shared_from_this?**
从一个raw指针上构造出一个shared_ptr,但是如果这个指针已经被别的shared_ptr管理了呢?这样会构造了2个shared_ptr指向同一个资源,但是这两个shared_ptr互相不知道对方无法

Shared_ptr<int> ptr=new int;  ->这个做法我想是错误的，无法编译

**智能指针参考shared_ptr四宗罪**
这些都是很久过时的文章，其实就是不懂得使用shared_ptr的结果
http://blog.liancheng.info/?p=85
严格限制获得指针的途径:
shared_ptr<>(new p)，除此外不能获得任意的pointer

可以将shared_ptr作为函数的参数 
void dosomething(shared_ptr<obj> ptr), 使用值传播没有问题
传递引用是否有overhead? -> 多线程环境中会有漏洞

http://www.sunyzl.cn/?p=238

## intrusive_ptr
intrusive_ptr用法头文件: "boost/intrusive_ptr.hpp"
intrusive_ptr 是shared_ptr的插入式版本。有时我们必须使用插入式的引用计数智能指针。典型的情况是对于那些已经写好了内部引用计数器的代码，而我们又没有时间去重写它(或者已经不能获得那些代码了)。另一种情况是要求智能指针的大小必须与裸指针大小严格相等，或者shared_ptr的引用计数器分配严重影响了程序的性能(我可以肯定这是非常罕见的情况！)。从功能的观点来看，唯一需要插入式智能指针的情况是，被指类的某个成员函数需要返回this，以便它可以用于另一个智能指针(事实上，也有办法使用非插入式智能指针来解决这个问题，正如我们在本章前面看到的)。intrusive_ptr 不同于其它智能指针，因为它要求你来提供它所要的引用计数器。

当 intrusive_ptr 递增或递减一个非空指针上的引用计数时，它是通过分别调用函数 intrusive_ptr_add_ref 和 intrusive_ptr_release来完成的。这两个函数负责确保引用计数的正确性，并且负责在引用计数降为零时删除指针。因此，你必须为你的类重载这两个函数，正如我们后面将看到的。

如何从derived class ptr转化到base class ptr?->如果可以转换的话，那么就直接作:
```
#if !defined(BOOST_NO_MEMBER_TEMPLATES) || defined(BOOST_MSVC6_MEMBER_TEMPLATES)

template<class U>
#if !defined( BOOST_SP_NO_SP_CONVERTIBLE )

intrusive_ptr( intrusive_ptr<U> const & rhs, typename boost::detail::sp_enable_if_convertible<U,T>::type = boost::detail::sp_empty() )

#else
用concept helper来判断,否则会出现:
test.cpp: In function ‘int main()’:
test.cpp:40: error: no matching function for call to ‘boost::intrusive_ptr<sjm2>::intrusive_ptr(sjmptr&)’
/boost/include/boost/smart_ptr/intrusive_ptr.hpp:89: note: candidates are: boost::intrusive_ptr<T>::intrusive_ptr(const boost::intrusive_ptr<T>&) [with T = sjm2]
/boost/include/boost/smart_ptr/intrusive_ptr.hpp:65: note:                 boost::intrusive_ptr<T>::intrusive_ptr(T*, bool) [with T = sjm2]
/boost/include/boost/smart_ptr/intrusive_ptr.hpp:61: note:                 boost::intrusive_ptr<T>::intrusive_ptr() [with T = sjm2]
```

如果func1,func2中参数时引用的话，就会出现:
```
test.cpp:59: error: invalid initialization of reference of type ‘sjmptr&’ from expression of type ‘sjm2ptr’
test.cpp:39: error: in passing argument 1 of ‘void func2(sjmptr&)’说明引用sjmptr2无法转换为sjmptr

#include <string>
#include "boost/smart_ptr.hpp"
#include "xtreme/common/intrusive_ptr_base.h"
#include <stdio.h>

using namespace std;
using namespace tbb;
using namespace xtreme;
class sjm2;
class sjm:public intrusive_ptr_base<sjm> {
public:
  ~sjm(){
    printf("sjm dtor\n");
  }
  int x;
};

typedef boost::intrusive_ptr<sjm> sjmptr;

class sjm2:public sjm {
public:
  ~sjm2(){
    printf("sjm2 dtor\n");
  }

  int y;
};

typedef boost::intrusive_ptr<sjm2> sjm2ptr;

void func1(sjm2ptr obj) {
}
void func2(sjmptr obj) {
}

int main() {
    sjmptr obj1(new sjm);
    sjm2ptr obj2(new sjm2);
    func2(obj2);
   printf("something\n");

}
```

## note--tbd
Boost智能指针小记 .
分类： C/C++ 2011-10-27 19:34 328人阅读评论(0) 收藏举报
参考资料：http://www.boost.org/doc/libs/1_47_0/libs/smart_ptr/smart_ptr.htm

[scoped_ptr]

模板类scoped_ptr储存着一个指向动态分配的对象的指针，可以通过reset方法显式释放对象，或者在scoped_ptr的析构函数中释放。

Scoped_ptr提供了基本的RAII机制，没有shared-ownership或transfer-of-ownership的语义问题。它的名字和语义表明了它的目的只是单纯地在当前作用域保持所有权，同时它继承于noncopyable。

由于scoped_ptr只是用于简单需求的简单解决方案，它本身设计就很简单，这使得它的操作跟内置指针一样快，并且不需要耗费额外的存储空间。

此外，scoped_ptr不能用于STL容器类和指向动态分配的数组的指针，如果需要，可以使用shared_ptr和scoped_array。一个比较经常的用法就是使用scoped_ptr来实现pimpl，避免在头文件中引入类的完整实现，可以减少编译时间等。

以下是scoped_ptr的概览：

[cpp] view plaincopyprint?
```
01.namespace boost {  
02.   
03.    template<class T> class scoped_ptr : noncopyable {  
04.   
05.    public:  
06.       typedef T element_type;  
07.   
08.       explicit scoped_ptr(T * p = 0); //never throws   
09.       ~scoped_ptr(); //never throws   
10.   
11.       void reset(T * p = 0); //never throws   
12.   
13.       T & operator*() const; //never throws   
14.       T * operator->() const; //never throws   
15.       T * get() const; //never throws   
16.   
17.       operator unspecified-bool-type() const; //never throws   
18.   
19.       void swap(scoped_ptr & b); //never throws   
20.    };  
21.   
22.    template<class T> void swap(scoped_ptr<T>& a, scoped_ptr<T>& b); //never throws   
23.   
24.}  
namespace boost {

    template<class T> class scoped_ptr : noncopyable {

    public:
       typedef T element_type;

       explicit scoped_ptr(T * p = 0); //never throws
       ~scoped_ptr(); //never throws

       void reset(T * p = 0); //never throws

       T & operator*() const; //never throws
       T * operator->() const; //never throws
       T * get() const; //never throws

       operator unspecified-bool-type() const; //never throws

       void swap(scoped_ptr & b); //never throws
    };

    template<class T> void swap(scoped_ptr<T>& a, scoped_ptr<T>& b); //never throws
}
```
以下是scoped_ptr的使用示例：
```
[cpp] view plaincopyprint?
01.#include <boost/scoped_ptr.hpp>
02.#include <iostream>
03.   
04.class MyClass  
05.{  
06.public:  
07.    MyClass(){ std::cout << "MyClass" << std::endl; }  
08.    ~MyClass(){ std::cout << "~MyClass" << std::endl; }  
09.   
10.    void MyFunc(){ std::cout << "MyFunc" << std::endl; }  
11.};  
12.   
13.int main(int argc, char *argv[])  
14.{  
15.    boost::scoped_ptr<MyClass> spMyClass(new MyClass);  
16.    spMyClass->MyFunc();  
17.    spMyClass.reset();  
18.   
19.    system("Pause");  
20.    return 0;  
21.}  
#include <boost/scoped_ptr.hpp>
#include <iostream>

class MyClass
{
public:
    MyClass(){ std::cout << "MyClass" << std::endl; }
    ~MyClass(){ std::cout << "~MyClass" << std::endl; }

    void MyFunc(){ std::cout << "MyFunc" << std::endl; }
};

int main(int argc, char *argv[])
{
    boost::scoped_ptr<MyClass> spMyClass(new MyClass);
    spMyClass->MyFunc();
    spMyClass.reset();

    system("Pause");
    return 0;
}
```

[shared_ptr]

顾名思义，shared_ptr智能指针能够共享所有权，并且它符合C++标准库中CopyConstructible和Assignable的要求，所以它可以用于STL的容器类上。通常，shared_ptr不能正确地管理数组指针，如果需要，可以使用shared_array。

智能指针shared_ptr通过引用计数来管理资源，所以存在循环引用的问题，可以通过weak_ptr来打破循环。在没有看源码前，可以思考下如何实现shared_ptr的引用计数，这对实践是有帮助的（显然是废话）。

下面两种初始化方式中，第一种是得到提倡的：
```
[cpp] view plaincopyprint?
01.boost::shared_ptr<MyClass> spMyClass1(new MyClass);  
02.  
03.MyClass *pMyClass = new MyClass();  
04.boost::shared_ptr<MyClass> spMyClass2(pMyClass);  
    boost::shared_ptr<MyClass> spMyClass1(new MyClass);

    MyClass *pMyClass = new MyClass();
    boost::shared_ptr<MyClass> spMyClass2(pMyClass);
```    
如果使用第二种，要避免出现如下代码，存在由于重复释放导致访问非法内存的错误：
```
[cpp] view plaincopyprint?
01.MyClass *pMyClass = new MyClass();  
02.boost::shared_ptr<MyClass> spMyClass1(pMyClass);  
03.boost::shared_ptr<MyClass> spMyClass2(pMyClass);  
    MyClass *pMyClass = new MyClass();
    boost::shared_ptr<MyClass> spMyClass1(pMyClass);
    boost::shared_ptr<MyClass> spMyClass2(pMyClass);
```

正确的做法应该是：
```
[cpp] view plaincopyprint?
01.MyClass *pMyClass = new MyClass();  
02.boost::shared_ptr<MyClass> spMyClass1(pMyClass);  
03.boost::shared_ptr<MyClass> spMyClass2(spMyClass1);  
    MyClass *pMyClass = new MyClass();
    boost::shared_ptr<MyClass> spMyClass1(pMyClass);
    boost::shared_ptr<MyClass> spMyClass2(spMyClass1);
```
这个可能在实践中出现的问题就与理解引用计数怎么实现的相关联。

此外，使用一个临时shared_ptr作为函参也可能出现问题，导致内存泄漏。因为C++参数的求值顺序是未定的（未求证，是没有相关标准还是编译器厂商自定义了？），比如下述代码的构造顺序可能为new int(2)，g()，shared_ptr，但是g()如果抛出异常呢？那么shared_ptr就构造不了，new了一个int，就没有释放了。

```
[cpp] view plaincopyprint?
01.f(shared_ptr<int>(new int(2)), g());  
f(shared_ptr<int>(new int(2)), g());
[weak_ptr]
```

前面说过shared_ptr存在循环引用的问题，使用weak_ptr可以解决。智能指针weak_ptr只能通过shared_ptr来构造，它可以管理shared_ptr指向的对象，同时不增加引用计数。

智能指针weak_ptr所能进行的操作是有限的，因为在多线程编程中使用它来获取存储的指针通常都是危险的，即便在单线程中，也可能引发问题，比如boost官网上展示的一段代码：
```
[cpp] view plaincopyprint?
01.shared_ptr<int> p(new int(5));  
02.weak_ptr<int> q(p);  
03.   
04.if(int * r = q.get())  
05.{  
06.    //use *r   
07.}  
shared_ptr<int> p(new int(5));
weak_ptr<int> q(p);

if(int * r = q.get())
{
    //use *r
}
```
存在执行q.get()后，另一个线程中指向相同对象的shared_ptr执行了reset的可能，对于这个问题，可以如下解决（同样来自官方）：(太长了，暂时忽略)
```
[cpp] view plaincopyprint?
01.shared_ptr<int> p(new int(5));  
02.weak_ptr<int> q(p);  
03.   
04.if(shared_ptr<int> r = q.lock())  
05.{  
06.    //use *r   
07.}  
shared_ptr<int> p(new int(5));
weak_ptr<int> q(p);

if(shared_ptr<int> r = q.lock())
{
    //use *r
}
```
成员函数lock()返回如下：

[cpp] view plaincopyprint?
01.expired()? shared_ptr<T>(): shared_ptr<T>(*this)  
expired()? shared_ptr<T>(): shared_ptr<T>(*this)
而expired()函数返回如下：

[cpp] view plaincopyprint?
01.use_count() == 0  
use_count() == 0


[intrusive_ptr]
之前说过shared_ptr存在一个问题，就是多次使用未经过包装的原生指针（raw pointer）进行构造，会导致多次析构，造成非法访问内存的错误。这是由于shared_ptr把引用计数放在shared_ptr结构中，所以使用原生指针构造会造成多份引用计数。

而intrusive_ptr则不存在这个问题，因为它把引用计数放在管理的对象中。同时，它要求对象必须有intrusive_ptr_add_ref和intrusive_ptr_release两个成员函数以供intrusive_ptr调用来管理引用计数。这也是intrusive_ptr的名称由来。

通常来说，如果使用intrusive_ptr的好处不是很明显，那么就优先考虑shared_ptr。


## auto_ptr特殊实现
函数里返回auto_ptr
例如：
```
template <class T>
std::auto_ptr<T> functionA(std::auto_ptr<T> pit)
{
    std::cout<<*pit<<std::endl;
    return pit;
}
std::auto_ptr<int> p2=functionA(p);            
```

函数里return pit,返回时先执行了一个copy ctor，
然后还要执行这个:
```
template<class _Other>
operator auto_ptr_ref<_Other>() _THROW0()
{    // convert to compatible auto_ptr_ref
  _Other *_Cvtptr = _Myptr;    // test implicit conversion
  auto_ptr_ref<_Other> _Ans(_Cvtptr);
  _Myptr = 0;    // pass ownership to auto_ptr_ref
  return (_Ans);
}
```
再把这个转化成一个auto_ptr
```
auto_ptr(auto_ptr_ref<_Ty> _Right) _THROW0()
{    // construct by assuming pointer from _Right auto_ptr_ref
  _Ty *_Ptr = _Right._Ref;
  _Right._Ref = 0;    // release old
  _Myptr = _Ptr;    // reset this
}
```

按照解释,需要用auto_ptr_ref来引用函数内的临时变量，但为什么不会直接用函数内的pit作为参数调用copy ctor?

因为auto_ptr不能真正地"copy"，所以只有这样的copy ctor:
    auto_ptr(auto_ptr&) throw()
它不能接受临时对象。
它是copy ctor，但T&不能接受临时对象。


### 临时变量绑定问题
【在 netwind 的来信中提到: 】
:
: hi
: 你说的这个还不是很明白
: 我把auto_ptr里那个auto_ptr_ref为参数的copy ctor函数去掉了，好像也能正常...
: 为何auto_ptr(auto_ptr &)这个不能作为正常的copy ctor?

: 是这个意思吗？
: 是这个意思吗？
```
class opB
{
public:
    int v;
};

class opA
{
public:
    opA(int l_v){v=l_v;}
    opA(opA &rhs){v=rhs.v;}
    opA(opB &rhsb)
    {
        v=rhsb.v;
    }
    operator opB()
    {
        opB b;b.v=this->v;return b;
}
    int v;
};

opA funca()
{
    opA a(5);
    return a;//这里会调用opA(opA &rhs){v=rhs.v;}正常吗？
}


void test()
{
 opA a1=funca();
}
```


正常，但下面的初始化应该失败，因为funca返回的是临时对象。
ps:函数返回值的时候，调用copy ctor，还是调用assignment?有点糊涂了
**其实就是无法绑定临时变量**
这段程序vc2008 exp可以通过的，但是gcc4.1.2报错:
vc2008 exp也该也挺新的了
```
tconst.cpp: In function ‘int test_const()’:
tconst.cpp:8: error: invalid initialization of non-const reference of type ‘X&’ from a temporary of type ‘X’
tconst.cpp:4: error: in passing argument 1 of ‘void g1(X&)’

class X{};
X func2(){return X();}
void g1(X&){}
void g2(const X&){}
int test_const()
{
    g1(func2() );//不可
    g2(func2() );//可以，const
    return 1;
}
```



22.13	智能指针smartpointer相关
可以参考shared_ptr四宗罪，性能是个严重的影响.引用计数需要LF或者mutex来保护
与weak_ptr的关系？

22.13.1	引用计数的实现
需求：多个handler(句柄，智能指针共享同一个数据)
需要在多线程中实现同步
参考C++沉思录p99


22.15	模板中的静态变量
22.16	模板的模板参数

# 模板

这个模板怎么实例化？
```
template <typename T>  
class Dynamic {
public:    
    int value;
};

template< template<class T> class U>
class FreeObj
{
public:
  int alue;
};

int main()
{
  FreeObj< Dynamic<int>> myobj;//error
}
```

这种模板不是这么用的。像这样就可以：
```
template <typename T>
class Dynamic {
public:
    int value;
};

template< template<class T> class U>
class FreeObj
{
public:
  U<int> alue;
};

int main()
{
  FreeObj<Dynamic> myobj;//error
}
```

经过验证，这个可以:
就是模板参数是另一个模板参数，需要用这个`template<class T>class U`指明他是一个模板参数
```
template <typename T>  
class Dynamic {
public:    
    T value;
};

//template< template<class T> class U>
template<class T0,template<class T>class U>
class FreeObj
{
public:
  U<T0> alue;
};

int main()
{
    FreeObj<int,Dynamic> myobj;
    return 0;
}
```


## MPL
```
class hasX
{
public:
 typedef int X;
};

class hasY
{
public:
 typedef int Y;
};
typedef char RT1;
typedef struct {char a[2];}RT2;

template<typename T> RT1 doth(typename T::X const *);
template<typename T> RT2 doth(...);

int main()
{
  int sz1=sizeof(doth<hasY>(0));//编译器能直接替换成求RT2的size大小？
  int sz2=sizeof(doth<hasX>(0));//
}
```
使用partial specialization c++
我连doth的函数的具体定义都没有，就是个声明
ANSWER:sizeof只需要类型信息，不会真的调用，有声明就够了

**is_same**
**enable_if**

