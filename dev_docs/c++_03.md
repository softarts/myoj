# misc
## size_t 头文件
```
uint8_t	#include <stdint.h>
size_t
```
## 数组
new初始化
如何new时创建一个数组及调用非缺省构造函数?new ClassD[5];
不能

## 复数类型
Complex<double> c;赋值: c=complex<double>(3.1,2.3)


## 逗号运算符
优先级最低, 一般就是分别进行运算， 参照多维数组的一个例子，（1,2,3）前面的会被忽略

##	switch 的特别之处
```
ds_dumpcache.cc:78: error: jump to case label
ds_dumpcache.cc:74: error:   crosses initialization of ‘int x’

switch (type) {
  case 2:
    read(l_imsi, f);
    int x = 10;
```
不允许在case里面再初始化变量？

## scanf压栈和内存数据
```
int main(){
  int a;float b,c;
  scanf("%2d%3f%4f",&a,&b,&c);
  printf("\na=%d,b=%d,c=%f\n",a,b,c);
}
9876543210I -> 输出 98， 0，0？
```
printf函数执行的时候，会先把这三个数字压入栈里，然后再执行打印。压入栈的时候按照数据本身的长度来，首先把c和b压入，并且每一个都是8个字节（printf自动转化为double）。然后再压入a是4个字节。然后再执行打印。打印的时候按照用户指定的格式来出栈。首先打印a，a打印正常。然后又打印4个字节长度的b，在栈里面由于b长度是八个字节，并且b目前是64位的表示方式，数据的后面全是0.（float 变double），电脑是小端存储方式，0存储在距离a近的地方。打印b的时候，打印的4个字节都是0.然后再打印c，c用正常的方式打印，会一下子读取8个字节，正好，读出来的八个字节前面四个字节全是0，自己可以算一下，实在太小了，因此为0.
```
栈底                                    栈顶
高字节。。。。。。。。。。。低字节
4321     0000      765     0000         98
4字节    4字节      4字节    4字节        4字节
      打印c                打印b         打印a
```

附：浮点数（单精度的float和双精度的double）在内存中以二进制的科学计数法表示，表达式为N = 2^E * F；其中E为阶码（采用移位存储），F为尾数。
float和double都由符号位、阶码、尾数三部分组成，float存储时使用4个字节，double存储时使用8个字节。各部分占用位宽如下所示：
```
             符号位     阶码      尾数     长度
float        1           8        23      32
double       1          11        52       64
```
这样b阶码为0？
目前64bit clang g++编译都得到不同的结果， 待测试32bit and vc

## this not assignable
```
ClassX::func() {this=0;} //wrong
```

## 位运算
反码详细释义 所谓原码就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。 反码表示法规定：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。 补码表示法规定：正数的补码与其原码相同；负数的补码是在其反码的末位加1。

负数在计算机中的表示（使用补码）:=对应的正数，取反码，然后+1
例如-2=~(2)->0x10->(反码bin)111..01  +1->(bin)1111..10,即0xfe

由计算机表示反推出负数-> (bin)1111...01 ->先减1 111..1100->取反0000011->3,然后加上符号位(-)即-3.

Bitwise complement 补码
正数的补码就是其本身
负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)
[+1] = [00000001]原 = [00000001]反 = [00000001]补
[-1] = [10000001]原 = [11111110]反 = [11111111]补
对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.
^ 异或运算 -> 1111^1010=0101


# 继承

## public/private 继承访问级别
基类本身指定对自身成员的最小访问控制。如果成员在基类中为 private，则只有基类和基类的友元可以访问该成员。派生类不能访问基类的 private 成员，也不能使自己的用户能够访问那些成员。
如果基类成员为 public 或 protected，则派生列表中使用的访问标号决定该成员在派生类中的访问级别：

1. 如果是Public 继承，基类成员保持自己的访问级别：基类的 public 成员为派生类的 public 成员，基类的 protected 成员为派生类的 protected 成员。
2. 如果是 protected 继承，基类的 public 和 protected 成员在派生类中为 protected 成员。
3. 如果是 private 继承，基类的的所有成员在派生类中为 private 成员。

假如，size 在 Base 中为 public，但在 Derived 中因为 private 继承 Base 后变为 private。为了使 size 在 Derived 中成为 public，可以在 Derived 的 public 部分增加一个 using 声明。如下这样改变 Derived 的定义，可以使 size 成员能够被用户访问，并使 n 能够被从 Derived 派生的类访问：
```
class Derived : private Base {
public:
  // maintain access levels for members related to the size of the object
  using Base::size;
protected:
    using Base::n;
    // ...
};
```

### 默认继承保护级别
上面介绍过用 struct 和 class 保留字定义的类具有不同的默认访问级别，同样，**默认继承访问级别**根据使用哪个保留字定义派生类也不相同。使用 class 保留字定义的派生默认具有 private 继承，而用 struct 保留字定义的类默认具有 public 继承。

##  友元关系不能继承
先看下面的代码：
```
class Base {
    friend class Frnd;
protected:
    int i;
};
// Frnd has no access to members in D1
class D1 : public Base {
protected:
    int j;
};
class Frnd {
public:
  int mem(Base b) { return b.i; }  // ok: Frnd is friend to Base
  int mem(D1 d) { return d.i; }    // error: friendship doesn't inherit
};
// D2 has no access to members in Base
class D2 : public Frnd {
public:
  int mem(Base b) { return b.i; } // error: friendship doesn't inherit
};
```
如上，基类的友元对从该基类派生的类型没有特殊访问权限。同样，如果基类和派生类都需要访问另一个类，那个类必须特地将访问权限授予基类的和每一个派生类。

## 继承与静态成员
如果基类定义 static 成员，则整个继承层次中只有一个这样的成员。无论从基类派生出多少个派生类，每个 static 成员只有一个实例。static 成员遵循常规访问控制：如果成员在基类中为 private，则派生类不能访问它。假定可以访问成员，则既可以通过基类访问 static 成员，也可以通过派生类访问 static 成员。一般而言，既可以使用作用域操作符也可以使用点或箭头成员访问操作符。
```
     struct Base {
         static void statmem(); // public by default
     };
     struct Derived : Base {
         void f(const Derived&);
     };
     void Derived::f(const Derived &derived_obj)
     {
        Base::statmem();      // ok: Base defines statmem
        Derived::statmem();   // ok: Derived in herits statmem
        // ok: derived objects can be used to access static from base
        derived_obj.statmem();     // accessed through Derived object
        statmem();                 // accessed through this class
```

### 阻止继承tbd
尽管大部分的STL类不是设计为基类，但并不能阻止被继承
```
class I32 : public string {
public:
	I32() :string() {}
};
```
可以继承string,
禁止继承参考C++经验- 实现final class


### 继承(virtual/protected/private)和多重继承(tbd)
多重继承主要的问题是命名冲突，假如A,B基类中都有相同的成员变量，函数，从A,B继承的C会造成错误，参考MorganStanley的C++ slide p248

Public 类型继承,is-a语义
Protected继承:只继承接口

### Private继承
实现继承,(基类的公有接口在派生类中变为private),其用意是不向外展现基类的接口，只供派生类内部使用
参考EFC 39,派生类和基类没有is-a关系.
```
Mylist:private std::list<int>
Mylist并不能使用list里的public 函数, 猜测自身可以使用这些private函数

void foo(const base &ap);
base b;
derived d;
foo(b); // ok
foo(d); // wrong
```
不会自动从derived class cast到base class,除非强制转换

所有的base 的成员在derived中都变成private,如果再从derived 派生grand child类的话，注意不能访问derived中那些变为private的变量

private继承实则上是一种实现技术，即只有父类的实现部分被继承。接口部分略去。Private在软件设计层面上没有意义。Private inheritance = is-implemented-in-terms-of,prefer composition to private-inheitence;

**使用场景**
不想构造一个is-a的派生类，但又想使用父类的实现.
这个时候如果父类里含有虚函数，那么在派生类中就会变成private virtual func()
还有一种极端情况是为了节省空间，一个什么成员都没有的empty 类也要占用(4bytes)空间，如果通过private继承，取得其所有的实现，加上派生类自身的成员int x,依然是4 bytes.因为base class不再是一个独立的类，而是派生类中的一部分。总的对象大小要比复合的情况小一些(假设复合里声明base class对象仍然要4 bytes?) EBO(空基类优化)只在单继承下有效

## 类模板和类继承的区别

模板与继承的本质区别之一是：模板：行为不依赖于类型。继承：行为依赖于类型。(Effective C++ Item 41) 事实上，在很多模式中都存在着可以用模板代替继承的情况，其根本原因就在于子类的行为是一致的。
模板中的T类不会影响类的行为,如果影像，使用继承和虚函数

## 多继承问题
类C继承于A,B，那么能否A,B中都有同样的函数声明，这会造成C中有多个函数声明(不会，属于不同的域)
会有2义性，一个派生类会被解释为两种基类，func(class base1&），func(class base 2&)就会造成2义性，使用域操作符来显式指定:obj.base1::foo

## Private 继承
基类的所有公共接口变为private（把基类作为成员对象不是更好？->果然），可以用using xxx::yyy来免除个别成员的私有继承影响:
```
Class derived:private xxx{
Public:
using xxx::yyy;};
```
类同的还有protected继承

**虚拟派生**
diamond inherite
B1,B2均从A派生，而C又从B1,B2多继承，虚拟派生会使派生类只有一个A的虚拟基类.
语法：B1,B2均须public virtual ….


# 类
## Access control
如果使用 class 关键字来定义类，那么定义在第一个访问标号前的任何成员都隐式指定为 private；如果使用 struct 关键字，那么这些成员都是 public。使用 class 还是 struct 关键字来定义类，仅仅影响默认的初始访问级别。默认情况下（没有使用任何关键字的场合），struct 的成员为 public，而 class 的成员为 private。

1. public: 程序的任何地方都能使用；
2. protected：只能是类本身及其派生类以及友元访问。并且，派生类只能通过派生类对象访问其基类的 protected 成员，派生类对其基类类型对象的 protected 成员没有特殊访问权限。像private一样，类的对象实例是不能访问的protected类成员的。

例如，假定 Bulk_item 定义了一个成员函数，接受一个 Bulk_item 对象的引用和一个 Item_base 对象的引用，该函数可以访问自己对象的 protected 成员以及 Bulk_item 形参的 protected 成员，但是，它不能访问 Item_base 形参的 protected 成员。

     void Bulk_item::memfcn(const Bulk_item &d, const Item_base &b)
     {
         // attempt to use protected member
         double ret = price;   // ok: uses this->price
         ret = d.price; // ok: uses price from a Bulk_item object
         ret = b.price; // error: no access to price from an Item_base
     }

3. private：只能是类本身，以及友元函数和友元类访问；**类的对象实例是不能访问 private 类成员的** ??

### 作用域是类
2015-06
C++的访问修饰符的作用是以类为单位，而不是以对象为单位。即在类的内部，可以访问另一个同类对象的私有变量，因为访问对象是‘对象’
```
class MyObj{
  test(MyObj *p)
  {
    p->private_value = 5;
  } // good
};
```

### 不同类对象的access control

基本上只有同类才能访问同类，而对于不同类对象，则依赖于类的访问规则如下限制:有private/protected等的限制。

Protect,private等的访问规则:（特指访问别的类对象的成员时的规则）
public自然就是公用的了，哪里都可以访问;protected和private在类外面是无法访问的:obj.protected_value =xxx NOK!

在类里面访问protected和private:当然可以直接访问自己的protected和private成员，
```
class base
{
  protected:
    int my_protected;
  private:
    int my_private;
};
class Derived:public base
{
public:
  int x,y,z;
protected:
  int a,b,c;
private:
  int u,v,w;
public:
  void test(Derived *pData){
    int temp = pData->u; ////派生类可以通过派生类的指针直接访问该类派生类其他实例的protectd
    temp = pData->a;      //以及基类中被定义成protected的成员;还有该对象的private成员
    temp = pData->my_protected;
    base *pBase=pData;
    //temp=pBase->my_protected;  //NOK但不能通过基类的指针来访问基类的protected成员。
    //temp = pData->my_private;  //NOK
 }
};

int main()
{
  Derived *pData1=new Derived;
  Derived *pData2=new Derived;
  base *pBase = new base;
  pData1->test(pData2);
  int temp = pData1->a;    //NOK, 无法访问protected对象
  temp=pBase->my_protected; //NOK, 无法访问protected对象
}
```
总结:access control是一种非常浅层的按照类别来提供访问控制的方法，无法针对对象，通过内存地址，可以用一种tricky的方法访问任何想要访问的东西.


通过基类的指针访问派生类的虚/函数可能出现的问题(p741 CPPP)

对于非静态成员，每个派生类都可以定义相同定义的自己的成员，或从基类继承!可以用VC++的debug工具察看类的具体结构，先是基类的对象，然后是自身的成员，ptr只有一份！?

class 声明中默认不是public类型，可能是private类型

static 变量和静态函数也有access control

域只能用在直接基类上:using base xxx(OK); using derived::base::xxx NOK



## 派生类到基类转换的可访问性
**TODO**
如果是 public 继承，则用户代码和后代类都可以使用派生类到基类的转换。如果类是使用 private 或 protected 继承派生的，则用户代码不能将派生类型对象转换为基类对象。如果是 private 继承，则从 private 继承类派生的类不能转换为基类。如果是 protected 继承，则后续派生类的成员可以转换为基类类型。
无论是什么派生访问标号，派生类本身都可以访问基类的 public 成员，因此，派生类本身的成员和友元总是可以访问派生类到基类的转换。


## 嵌套类
外部类对嵌套类的成员并没有访问特权，依然按照access control


# 函数重载/覆盖


## RTTI实现
typeid()的结果
```
VB *a = new VB();
if (typeid(*a) == typeid(VB)) {
std::cout << typeid(*a).name() << std::endl;
}
```
会打印出class VB
这些信息保存type_info 对象里，通过typeid()来访问type_info对象，RTTI被设计成依赖vtable来实现，往往类型信息type_info保存在虚函数表的第一项，也有说保存在前移4bytes,但是取决于编译器实现。

## 操作符重载
```
class myless
{
public:
  myless(int a,int b)
  {
    cout<<"ctor"<<std::endl;
  }
  void operator()(int a,int b)
  {
    cout<<"operator"<<std::endl;
  }
};
```


Myless(5,6) ->调用ctor
Myless(5,6)(5,6) ->调用operator()(int,int)

类成员与非成员
类成员的参数比非成员函数要少一个，例如,unary类成员的话不需要参数

重载operator<<
只能作为非成员函数重载?如果是成员函数的话，调用它们时就必须把string对象放在它们的左边：

```  
不完整代码
ostream& operator<<(ostream& output);
operator==
#include <vector>
struct A{
    std::vector<int> i;
};

int main()
{
    A a;
    a == a;
    return 0;
}
无法编译，因为没有实现operator==
```

## 操作符重载
->,[] ，Operator =只能是成员函数,参考D&E
重载operator() TBD


## overload/override/overwrite
this,很重要,调用每一个函数,this都作为一个指针传递进去.有时候class*(NULL)->func()可以执行,就是因为this为NULL不影响函数的执行.对于func() const,this也为const

Overload Overwrite Override [C++]2010-06-09 14:31

### Overload(重载)

在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载。

- 相同的范围（在同一个类中）；
- 函数名字相同；
- 参数不同；
- virtual 关键字可有可无。

Override(覆盖)：是指派生类函数覆盖基类函数，特征是：
- 不同的范围（分别位于派生类与基类）；
- 函数名字相同；
- 参数相同；
- 基类函数必须有virtual 关键字。

Overwrite(重写)：是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
- 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual
关键字，基类的函数将被隐藏（注意别与重载混淆）。
- 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual
关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。

特别注意

如果基类有某个函数的多个重载（OVERLOAD）版本，而你在子类中重写(OVERWRITE)了其中的一个，或是子类添加新的函数版本，则所有基类的重载版本都被遮蔽。所以，正常情况下，在子类中应重写基类中的所有重载版本。

具体地讲，继承类中的重载和重写都包含了重写的涵义，即只要函数名一样，基类的函数版本就会被遮蔽，所以，在派生类中要保持基类的重载版本，就应该重写所有基类的重载版本。重载只在当当前类中有效，继承会失去重载的特性。也就是说，把基类的重载函数放在继承类里，就必须重写。

以上这段文字可对应EFC的item

1. 允许基类和派生类中存在同样的函数吗？
对于非虚函数，这是overwrite,)可以,同一个类中构造函数可以有多个，析构函数只能有一个
对于EC中建议不要改写基类中的非虚函数:那样是一种overwrite覆盖,

2. 类型转换只允许派生类->基类，而不允许基类->派生类,如B:public A, A *pA=new B;即B upcasting->A
即upcast是安全的，downcast不安全.基类在最上方

3. 绑定哪一个对象的函数，取决于实际的对象(而不是指针)，例如B:public A, A *pA=new B;实际的对象是B,如果实际的对象没有该函数，则会向上查找，多继承中，会根据指针自身类型判断从哪个域查找(这是没完整学过C++时的想法)

4. virtual告诉编译器晚绑定一个函数,给每个包含虚函数的类创建一个指针指向vtable,对象中同时保存着一些类型信息,如果基类的虚函数是private,而派生类的虚函数是public,基类的指针->派生类对象调用虚函数(虽然会调用派生类的函数)还是存在问题，因为晚绑定并不知道实际调用的是谁.(同时说明每个类一个虚函数表，而不是毎个实例)
注意虚函数表的生成！???
编译器帮助我们在构造函数中初始化vtable

5. 只有在使用对象的地址的时候才存在虚函数的绑定问题，如果使用对象，可以早绑定

7. 声明纯虚函数=0,只是定义一个格式，vtable是不完全的(该表有些项地址为0)，必须对函数进行实现,否则报编译错误，vc和gcc对纯虚函数是否要实现判断不同???(tbd)

8. 假如指针是pA,指向B对象，然后调用pA->fB(),fB只存在于B对象，那么编译时就会报错（不是虚函数的话，A里没有该函数的定义）.因为晚绑定不能确定对象的类型,编译器不知道具体会调用A还是B的函数,可以强制向下映射((B*)pA)->fB(),(做了无用功)
但向下(基类指针转化为派生类)映射是不安全的,可以利用RTTI运行时类型辨别来做->实质是没有声明fB函数，当然无法编译

9. 传递对象的话可能会被切片，对象是确切知道的信息，会被早绑定

10. 构造函数先基类再派生类，虚机制在构造函数中不工作，构造函数中调用的虚函数都是本地版本，它不知道当前这个类后面的派生类的情况

11. 析构函数常常是虚的，因为析构函数从最顶层调用，知道当前的类是那个派生类。Delete ptr的时候可以根据指针指向的实际对象来调用虚析构函数

13. C++中不允许纯虚函数声明后又定义？ virtual ~base() = 0 {cout<<"~base()"<<endl;}?????

14. 通过某对象的基类指针来调用delete,如果基类没有虚析构函数的话，那么只会执行基类的析构函数(也就是该指针类型所对应的析构函数)从而可能造成内存泄漏.如果是该指针类型中有虚析构函数，则会先调用指针所指向的对象的析构函数

15. 类中有虚函数的时候，就应该提供虚析构函数.??析构函数中也不会调用虚函数，只会调用函数的本地版本(因为是晚绑定机制，不知道虚函数的派生对象是否已被删除)

注意！虚函数，如果基类和派生类中的函数参数一样，那么他们的返回类型必须一致(因为无法根据返回值来分别函数)；如果参数不一致，那么即函数不一样(不一致的参数等于不同的函数定义，以至于派生类中没有实现这个函数?)这既不是函数重载，也不是覆盖，…是隐藏?(也不合理，总之根据指针类型，可能无法使用另一个类的成员函数！)当基类的虚拟函数返回类的类型时/指针/引用时，派生类的虚函数可以声明返回类型为该类的派生版本。
一般准则,先判断是否存在虚函数，无->执行指针自身类型指向的函数，有虚函数->执行指针指向对象的类型的函数

看一下这个就行了：
```
#include"stdafx.h"
#include<stdio.h>
class Base
{
public:
void foo()
  {
    printf("Base::foo()\n");
  }
};
class Derived: public Base
{
public:
void foo()
  {
    printf("Derived::foo()\n");
  }
};
int _tmain(int argc, _TCHAR* argv[])
{
  Base *ptr = new Derived();
  ptr->foo();
  ((Derived *)ptr)->foo();
return 0;
}
```

执行结果：
Base::foo()
Derived::foo()
ptr到底会调用哪个函数，不是由ptr所指对象决定，而是由ptr的类型决定，这就是“精神分裂”,根源是由于非virtual的函数是静态连接的

注意！将一个指向基类的指针，强制转换成派生类的指针后，去调用派生类的函数，有无问题？没有问题，也可以对变量赋值，但实际上对象仍然是基类，可能造成读写非法内存！upcast是安全的，而上例造成的是downcast，不安全！



## 当基类存在重载函数的时候，派生类掩盖了基类虚函数

简而言之，如果基类的虚函数有重载了，通过早绑定调用派生类，并不能调用到基类的被掩盖的函数，除非使用using

派生类中的同名虚函数掩盖了基类中的虚函数，但仍可以通过指针调用基类版本的函数  
参考effective c++ item 33  
  
如下:  
```
class I33base1 {  
public:  
  virtual float foo(int &a) {  
    std::cout << "i33 base" << std::endl;  
    return 0.0;  
  }  
  virtual float foo() { return 0.0; }  
};  
  
class I33child1 : public I33base1 {  
public:  
  virtual float foo() { return 0.0; }  
};  
  
void test() {  
  int j = 10;  
  //不可以通过派生类对象调用  
  I33child1 c1;  
  c1.foo(j); // compile error,符合预期，这是早绑定  

  //通过指针调用可以  
  I33base1 *pc3 = new I33child1();  
  const int i = 10;  
  pc3->foo(j); // ok  
}  
```
这该怎么解释呢？
这个问题的重点在于你使用了基类指针，如果你把它改成派生类指针，是符合你的预期的。
基类指针使得你的编译器对于pc3的处理是按照基类处理，会出现以下三点：
1、基类的成员在pc3中可见，所以你使用pc3->foo(j)不出错。
2、派生类中非基类成员被屏蔽，如果你派生类追加了一个foo1函数，在pc3中使用foo1是报not match错误的。
3、如果派生类中有继承实现了基类的同名virtual函数，那么pc3中使用这个函数的时候使用的是派生类版本。

## 放松覆盖规则

放松覆盖规则,在C++中，只要原来的返回类型是指向类的指针或引用，新的返回类型是指向派生类的指针或引用，覆盖的方法就可以改变返回类型。这样的类型称为协变返回类型（Covariant returns type).

这个条目来自于C++ D&Ep242，就是允许这样的代码:
```
#include <iostream>
using namespace std;

class B
{
public:
  virtual B* clone(){return new B(*this);} 
  //virtual const B clone2() { return B();}
  virtual const B& clone2() { auto ptr=new B;return *ptr;}
  virtual void foo(B*) {cout <<"B foo\n";}
};

class D:public B
{
public:
  //B*clone() {return new D(*this);} //和D* clone()不能同时存在，这两个应当看作是一个virtual func, 允许返回类型不一样，但必须是相关的类引用或者指针
  D* clone() {return new D(*this);}
  //D clone2() {cout<<"D clone2\n";return D();} //invalid covariant，不允许value
  const D& clone2() {cout<<"D clone2\n";auto ptr=new D;return *ptr;} //允许
  void foo(D*) {cout <<"D foo\n";}
  void foo(const D*) {cout <<"const D foo\n";}
};

int main() {
  D *pd = new D;
  pd->clone();
  pd->clone2();
  pd->foo(pd);
  const D* cpd = pd;
  B *pb=new B;
  pb->foo(pd);
  pd->foo(cpd);
}
=>
D clone2
D foo
B foo
const D foo
不过注意，B指针无法接受const D*的参数，因为没有声明
```
## 重载、覆写和隐藏的区别
不要覆盖基类的non-virtual func,这会造成代码难以维护

重载:编译器只考虑左操作数的类中定义的成员重载操作符
[],=,(),->必须用类成员定义
考虑如下的操作符重载：
A:
Data& operator=(char *str){cout<<"operator(char *)="<<str<<endl;}
B:
Data& operator=(const char *str){cout<<"operator(const char *)="<<str<<endl;buf=str;}
当:
Data testobj;
testobj="teststring";
的时候，调用的是B重载,

C++ primer 3rd中p617说obj="teststring"这种形式调用的是B形式的重载，A形式是不允许的，但实际上只有A形式的时候，会发现它调用了A形式的重载，也就是说编译器隐式的支持这种转换，这种行为正确吗？(正确)
编译器:gcc3.4.6
成员函数被重载的特征：

重载和覆盖:
（1）相同的范围（在同一个类中）；
（2）函数名字相同；
（3）参数不同；
（4）virtual关键字可有可无。
相当于重载，只是参数不同

覆盖是指派生类函数覆盖基类函数，特征是：
（1）不同的范围（分别位于派生类与基类）；
（2）函数名字相同；
（3）参数相同；
（4）基类函数必须有virtual关键字。
相当于使用虚函数

隐藏
令人迷惑的隐藏规则

本来仅仅区别重载与覆盖并不算困难，但是C++的隐藏规则使问题复杂性陡然增加。这里“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：

（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。(这就要利用前面提过的using，或者显式调用基类的函数)

（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。(即根据指针自身的类型去调用具体的函数)


编译器如何识别声明为父类但实际指向子类对象的指针？或者用C如何来实现

# 虚函数
## 引用也会触发虚函数机制:
例如:void draw(base &obj){obj.draw(); }  实际调用时会根据obj的具体指向来运行

包含纯虚函数的类是无法被实例化的

多态:只存在于类继承层次中
派生类的指针->指向基类对象，无法编译通过(可能派生类中的函数，基类中不存在)
基类的指针->指向派生类对象，编译通过,无警告

缺省实参是在编译时刻确定的(根据被调用函数的对象的类型，也就是指针自身),而晚绑定是绑定哪一个类的函数。

##	虚函数表
```
struct A｛｝
struct B：A｛｝
```
通常每个类都会有一个虚函数表，如果B没有增加新的虚函数，那么它可以和A共用一个。否则它会新产生一个虚函数表，里面包含了AB所有的虚函数，但没改动的虚函数仍然指向A的虚表的位置。

lldb 查看虚函数：
```
breakpoint set –file foo.c –line 84
image lookup -r -v -s "diamond1::C"
6 symbols match the regular expression 'diamond1::C' in ./bin/bitcodech:
        Address: bitcodech[0x000000010000c640] (bitcodech.__TEXT.__text + 44640)
        Summary: bitcodech`diamond1::C::C() at diamond.cpp:66
         Module: file = "./bin/bitcodech", arch = "x86_64"
    CompileUnit: id = {0x00000000}, file = "/Users/zhour/work/codechallenge/cpp/cpp11/basic/diamond.cpp", language = "c++"
       Function: id = {0x20000ce4a}, name = "C", range = [0x000000010000c640-0x000000010000c65b)
       FuncType: id = {0x20000ce4a}, decl = diamond.cpp:66, compiler_type = "void (void)"
         Blocks: id = {0x20000ce4a}, range = [0x10000c640-0x10000c65b)
      LineEntry: [0x000000010000c640-0x000000010000c650): /Users/zhour/work/codechallenge/cpp/cpp11/basic/diamond.cpp:66
         Symbol: id = {0x000003f1}, range = [0x000000010000c640-0x000000010000c660), name="diamond1::C::C()", mangled="_ZN8diamond11CC1Ev"
       Variable: id = {0x20000ce68}, name = "this", type = "diamond1::C *", location =  DW_OP_fbreg(-8), decl = 
        Address: bitcodech[0x000000010000ce20] (bitcodech.__TEXT.__text + 46656)
        Summary: bitcodech`diamond1::C::C() at diamond.cpp:66
         Module: file = "./bin/bitcodech", arch = "x86_64"
```
并不是很有意义，只是列出了每一个func被name mangle


##	虚函数的signature/name hiding
http://codefine.site/1654.html

同一个虚函数指的是，返回值相同(允许基类/派生类的变化)，参数必须完全相同(cv除外)，包括const等修饰符也要相同。一个重载虚函数不能扩展在基类的函数里声明的异常集，但是可以缩小它。

如果参数不同，那么派生类中的同名虚函数掩盖overhide了基类中的虚函数，但仍可以通过指针调用基类版本的函数,通过对象访问则不可以。(早绑定)， 所以应该避免这种做法
**参考effective c++ item 33** 
  
如下: 
```
class I33base1 { 
public: 
     virtual float foo(int &a) {  
         std::cout << "i33 base" << std::endl; 
         return 0.0;  
     } 
     virtual float foo() { return 0.0; } 
}; 
  
class I33child1 : public I33base1 { 
public: 
     virtual float foo() { return 0.0; } 
}; 
  
void test() { 
     //不可以通过派生类对象调用 
     I33child1 c1; 
     c1.foo(j); // compile error 
     //通过指针调用可以 
     I33base1 *pc3 = new I33child1(); 
     const int i = 10; 
     int j = 10; 
     pc3->foo(j);  // ok 
} 
```

这该怎么解释呢？ 
通过对象调用，会受到hide的影响，而通过指针访问，保留虚函数的特点。
参考vc生成的虚函数表，可以看到I33child1的虚函数表仍然是两个项。因为虚函数 signature不一样
```
1>  I33base1::$vftable@:
1>  	| &I33base1_meta
1>  	|  0
1>   0	| &I33base1::foo 
1>   1	| &I33base1::foo 
1>  
1>  I33child1::$vftable@:
1>  	| &I33child1_meta
1>  	|  0
1>   0	| &I33child1::foo 
1>   1	| &I33base1::foo 
1>  
```
CV (CONST VOLATILE)对虚函数的影响
```
class I33base2{
public:
	virtual int foo(const float x) { return 0; }
	
};

class I33child2 : public I33base2{
public:
	virtual int foo(float x){ return 0; }
	//virtual int foo(const float x) { return 0; }
};

I33child2 *pc2 = new I33child2();
I33base2 *pc2_1 = pc2;
I33base2 *pc2_2 = new I33base2();
I33child2 *pc2_3 = (I33child2 *)pc2_2;
const float i = 0.1f;
pc2->foo(i);    //derived
pc2_1->foo(i);  //derived
pc2_2->foo(i);  //base
pc2_3->foo(i);  //base

虚表layout
1>  I33base2::$vftable@:
1>  	| &I33base2_meta
1>  	|  0
1>   0	| &I33base2::foo 
1>  
1>  I33child2::$vftable@:
1>  	| &I33child2_meta
1>  	|  0
1>   0	| &I33child2::foo 
```

https://msdn.microsoft.com/en-us/library/bb384874.aspx
Your application contains a method in a derived class that overrides a virtual method in a base class, and the parameters in the overriding method differ by only a const or volatile qualifier from the parameters of the virtual method. This means the compiler must bind a function reference to the method in either the base or derived class.
试图在派生类中override基类的函数，而这个函数的参数仅有const/volatile的差别。编译器必须决定使用哪一个。

Versions of the compiler prior to Visual C++ 2008 bind the function to the method in the base class, then issue a warning message. Subsequent versions of the compiler ignore the const or volatile qualifier, bind the function to the method in the derived class, then issue warning C4373. This latter behavior complies with the C++ standard.
Vc2008之后均使用派生类中的版本，但会发出warning.(不解，何谓bind function reference?动态绑定何来bind一说)

says that top-level cv qualifiers on parameter types do not make for distinct parameter lists. foo(int) and foo(const int) are the same function

C++标准说cv对区分虚函数没有影响。因此vc2008之后的版本都把他们看作同一个虚函数声明
**结论，有无cv均看作是同一个虚函数，MSDN的warning可能只是针对其早期编译器的行为。测试结果与结论吻合.**

##	Virtual operator assignment 特殊处理无法解释tbd
这个牵涉到默认operator= TBD
https://stackoverflow.com/questions/669818/virtual-assignment-operator-c
```
namespace vfuncsig1 {
    class I33base {
    public:
        virtual I33base & operator=(const I33base &rhs){
            std::cout << "i33 base" << std::endl;
            return *this;
        }
    };

    class I33child : public I33base {
    public:
        virtual
        I33child & operator=(const I33child &rhs){
            std::cout << "i33 child" << std::endl;
            return *this;
        }
    };

    void test() {
        I33base b1;
        I33child c1,c2;
        c1=c2;  // -> i33 child
    }
}

namespace vfuncsig2 {
    class I33base {
    public:
        virtual I33base & operator=(const I33base &rhs){
            std::cout << "i33 base" << std::endl;
            return *this;
        }
    };

    class I33child : public I33base {
    public:
        virtual
        I33child & operator=(const I33base &rhs){
            std::cout << "i33 child" << std::endl;
            return *this;
        }
    };

    void test() {
        I33child c1,c2;
        c1=c2;  // -> i33 base
    }
}
```
无法解释为何第二项调用的是i33 base
和参数类型有关？
对于sig2虚函数表有几项？

## Virtual继承(虚继承)
主要用于避免多继承中产生多个基类的实例

The rules governing the initialization of virtual base classes are more complicated and less intuitive than are those for non-virtual bases. The responsobility for initializing a virtual base is borne by the most derived class in the hierarchy. When a new derived class is added to the hierarchy, it must assume initialization responsiblities for its virtual bases (both direct and indirect)

http://www.cnblogs.com/BeyondAnyTime/archive/2012/06/05/2537451.html
注意SCB 中中间一层有一个并没有虚继承
比较常见的就是diamond继承问题,钻石继承问题
Virtual继承的实则是在runtime的时候才能决定base的具体位置.如图


##	C++中虚函数表实现 （TBD）
大家都知道C++中的虚函数的实现一般是通过虚函数表(C++规范并没有规定具体用哪种方法，但大部分的编译器厂商都选择此方法)，下面通过虚函数表来看看C++中虚函数的实现
先说结论，我认为每个类都有一张自己的虚函数表

```
class A
{
public:
  virtual void func(){cout<<"A-func"<<endl;}
};

class AA:public A
{
public:
  void func() {cout<<"AA-func"<<endl;}
};

int main()
{
  AA*paa=new AA;
  A*pa=new A;
}
```
可以看到paa指向的AA对象中，其子对象A的虚函数表(vftb)地址为0x0047e69c，正好是AA对象的首32位
一般编译器实现，均将首4bytes作为虚函数表地址。
倘若将类定义改成:
```
class A
{
public:
  virtual void func() {cout<<"A-func"<<endl;}
};

class AA:public A
{
public:
  //void func(){cout<<"AA-func"<<endl;} 
};
```

那么可以看到paa中的虚函数表中的第一个项(即从A继承而来的func)，和pa中虚函数表的第一个项(A中的func)，都指向同一个地方(0x004010f5)，
可以得出这样一个结论：
当派生类没有覆盖(override)基类中的虚函数时，那么这个虚函数就会指向基类的虚函数实现(也即使用同一个函数实现！并非同一个虚函数表)。在C#中也有类似的概念，C#中的override关键字即表明派生类需要改写基类中虚函数项的指向。

在派生类中新增一个virtual func 虚函数
```
class ZA
{
public:
	int ai;
	virtual void func(){ std::cout<< "A-func" << std::endl; }
	virtual void func2(){ std::cout<< "A-func2" << std::endl; }
};

class AA:public ZA
{
public:
	void func(){ std::cout<< "AA-func" << std::endl; }
	virtual void aa_func(){ std::cout<< "AA-aa_func" << std::endl; }
};
```
 
对于这份代码，VS2005的debugger并没有正确反映出AA中aa_func的位置

VS2015 vftable同样的结果，是否vs2015只显示前两项? 直接查看数组[2]是可以看到该项的。可以看到生成了两个不同的虚表(aa660/aa600)，但是她们的func2()指向同一个位置，说明没有被override. *pab也只是显示前两项(可能是vs2015无法得知虚表的实际数目?,如果只有一项是可以显示的)

**使用GCC编译,察看虚函数表**
g++ -fdump-class-hierarchy  -c seetable.cpp  (clang not working)
```
Vtable for B
B::_ZTV1B: 5u entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI1B)
16    B::func
24    A::func2
32    B::aa_func
```
可见是放在一张表里.

## 汇编角度看虚函数表
让我们回忆一下上一篇关于C++的类型转换的过程:
AA *paa = new AA;
这时候paa指向了AA的一个实例(instance)
A *pa = new AA;
这时候pa指向的仍然是AA的这个实例
因此，pa->func 和 paa->func都指向了AA实例中vftb的第一项(**这里可能有些错误，是指向同样的函数位置**)，也就是AA:func()，为什么指针可以呈现出多态的原因也就不言而喻了。(对于引用也是同样的道理),即根据实例，而不是根据指针，指针可以多态。

再来看看非虚函数和虚函数的汇编代码:
```
class A
{
public:
	int ai;
	virtual void func(){cout<<"A-func"<<endl;} //看看(有/没有)virtual的汇编代码
};

class AA:public A
{
public:
};

非虚函数:
	paa->A::func();
004010C6  mov         ecx,dword ptr [paa]
004010C9  add         ecx,4   //将paa对象压栈(偏移4是因为首4个字节保存的是vftb虚函数表)
004010CC  call        A::func (401046h)
虚函数:
	paa->func();
00401230  mov         edx,dword ptr [paa]  //paa对象->edx
00401233  mov         eax,dword ptr [edx]  //vftb->eax
00401235  mov         ecx,dword ptr [paa]  //paa对象->ecx
00401238  mov         edx,dword ptr [eax]  //vftb的第一项->edx，也就是func所在的位置
0040123A  call        edx  
```
经过一系列”复杂”的计算，最后edx寄存器里存放的就是func的正确地址，这也叫做late-binding(迟绑定)


最后看看虚函数导致对象的内存布局
当基类中没有虚函数的时候，自然基类也就没有虚函数表，而当基类中有虚函数的时候，编译器产生一个虚函数表，派生类就使用其基类子对象中的虚函数表.
```
class A
{
public:
	int ai;
	virtual void func2() {cout<<"A-func2"<<endl;}	
};
class AA:public A
{
public:
	void func() {cout<<"AA-func"<<endl;}
	virtual void aa_func(){cout<<"AA-aa_func"<<endl;}
};

Vftb的第一项是A中的func2()，而第二项是AA中的aa_func
```

**使用编译器来检查virtual table**


## 多重继承(无虚基类)
```
class Base {
protected:
  int foo;
public:
  virtual int method(int p) {
    return foo + p;
  }
};

class AA :public Base {
public:
  int aa1,aa2;
  virtual void aafunc() {}
};

class AB:public Base {
public:
  int ab1,ab2;
  virtual void abfunc() {}
};

class Derived : public AA,public AB {
public:
  int method(int p) {
    return 1 + p;
  }
  virtual void dfunc() {}
protected:
  char d1;
};
```
Derived类的layout如图：
```
*** Dumping AST Record Layout
         0 | class Derived
         0 |   class AA (primary base)
         0 |     class Base (primary base)
         0 |       (Base vtable pointer)
         8 |       int foo
        12 |     int aa1
        16 |     int aa2
        24 |   class AB (base)
        24 |     class Base (primary base)
        24 |       (Base vtable pointer)
        32 |       int foo
        36 |     int ab1
        40 |     int ab2
        44 |   char d1
           | [sizeof=48, dsize=45, align=8,
           |  nvsize=45, nvalign=8]
```

通过vs2015检验可知：
使用位于对象0byte的地方（也就是AA子对象的起始处）保存了指向位于 70c08地址处的虚表的指针，这个虚表一共有3项，分别是method(3a1c),aafunc(277a),dfunc(40fc)，这个虚表理解为Derived类新产生的虚表。而在AB子对象的起始处还有一个指向虚表70c30的指针，这个实质上就是AB类的虚表，里面有两项，1项是一个adjustor到method()的trunk,第二项是AB:abfunc()
 

结论，vc2015并没有为多重继承的一个类产生多个虚表，而是产生多个虚表的指针。




##	Vs2015展示的虚函数内存布局以及G++ dump vftable

一个简单的继承关系，基类声明一个虚函数，派生类声明一个新的虚函数，vs2015中看到派生类居然有2个vftable。
然而再仔细看这两个vftable都是指向同一个地址f378,所以这只是vs2015展示的问题而已，并不等于实际rhs有2个vftable.只是说明从A中继承了一个虚函数，rhs自身又有另一个虚函数。

VC dump 虚函数表的layout编译开关： /d1 reportAllClassLayout 
如果工程很庞大，会导出很多东西


g++ -fdump-class-hierarchy -g -c dia.cpp dump出虚函数表。

diamond继承可能的D memory layout,可以有3个vptr，指向3个虚函数表，另外还有ptr to offset.从而增大对象尺寸，新加入继承体系的类／最底层的类要承担虚基类的初始化工作，可用于实现final class TBD
http://www.phpcompiler.org/articles/virtualinheritance.html

## 虚继承的布局(tbd)

首先看不使用虚继承的情况
```
class A
{
public:
  int ai;
  virtual void func(){cout<<"A-func"<<endl;}
};

class AA:public A
{
public:
  void func() {cout<<"AA-func"<<endl;}
  virtual void aa_func() {cout<<"AA-aa_func"<<endl;}
};

class AB:public A
{
public:
  int ab;
};

class C:public AA,AB
{
public:
  int c;
  void func()
  {
	cout<<"C-func"<<endl;
	AB::func();
  }
};


int _tmain(int argc, _TCHAR* argv[])
{
C c;
//cout<<c.c<<endl;
c.func();
return 0;
}
```
不采用虚继承的结果是，C中的AA和AB两各自对象都有一个公共的子对象A，这无形中增大了对象的size，有两个vftable(这句话存疑)，增加了内存开销。


vs2015 显示在C对象中，子对象AA和AB有2个指向vftable的指针，然而这并不是指向AA/AB的虚表,而是指向C自身的虚函数表？ (应该是C的虚表，一个class有一个虚表)
如果A,AA,AB,C都声明了新的虚函数，从vs2015的情况看C中的AA子对象的vftable并不是指向AA的虚函数表，而是，可能指向的C产生的自身的虚函数表!!（正解）

```
namespace diamond1 {
	class A
	{
	public:
		int ai;
		virtual void func() { cout << "A-func" << endl; }
	};

	class AA :public A
	{
	public:
		void func() { cout << "AA-func" << endl; }
		virtual void aa_func() { cout << "AA-aa_func" << endl; }
	};

	class AB :public A
	{
	public:
		int ab;
		virtual void ab_func() { cout << "AB-ab_func" << endl; }
	};

	class C :public AA, AB
	{
	public:
		int c;
		void func()
		{
			cout << "C-func" << endl;
			AB::func();
		}
		virtual void cfunc() { cout << "C-cfunc\n"; }
	};
	void test() {
		A a;
		AA aa;
		AB ab;
		C c;
		//cout<<c.c<<endl;
		c.func();
	}
}
```
(原图缺失)
可以看到A:vfunc的地址都不一样。(a,ab一样，然而C中的func并不一样,因为C中override了func(), )
如果C中没有override func(),那么就会看到他的两个func都指向了AA/AB中的func实现。

使用虚继承的内存布局
产生了3个vftable？758(A&C共用一个)，740，720分别是aa，ab。将公共子对象A放在最后以节省内存
AA/AB/A依次排列，然后AA,AB里都带有A子对象的vftable,指向A的func实现（3076）

然而C的虚表在哪里？（758）
多重继承里，派生类有n-1个base class带来的虚表+加上自身。

（所以这段话没什么结论）下图，当AA virtual public A而AB并没有这样做的时候，发现C产生的子对象AB的虚函数表不见了！但总的虚函数表还是3个。（实质上使用的就是978，只不过ide没有显示出来，而上图由于都做了virtual 继承，所以共用了A的虚表）

看看反汇编
```
45: 	c.func();
00411566 8D 4D E4         lea         ecx,[c]
00411569 E8 30 FD FF FF   call        C::func (41129Eh)
```
回忆前面提到的虚函数的工作原理，编译器需要初始化每个对象的虚函数指针，在这个例子中，看到两个A子对象中的vftable[0]项的内容，均是指向c::func()，但具体的实现有些不同，AB中的A子对象的vftable[0]指向一个特殊的位置:0x4112A3 (这称为adjust-chunk)
```
0041129E E9 5D 03 00 00   jmp         C::func (411600h)
004112A3 E9 38 03 00 00   jmp         [thunk]:C::func`adjustor{8}' (4115E0h)
0x411600就是C::func的具体位置

跳转到411600:
   29: class C:public AA,AB
    30: {
    31: public:
    32: 	int c;
    33: 	void func()
    34: 	{
00411600 55               push        ebp  
00411601 8B EC            mov         ebp,esp
00411603 81 EC CC 00 00 00 sub         esp,0CCh
00411609 53               push        ebx  
0041160A 56               push        esi  
0041160B 57               push        edi  
0041160C 51               push        ecx  
0041160D 8D BD 34 FF FF FF lea         edi,[ebp-0CCh]
00411613 B9 33 00 00 00   mov         ecx,33h
00411618 B8 CC CC CC CC   mov         eax,0CCCCCCCCh
0041161D F3 AB            rep stos    dword ptr es:[edi]
0041161F 59               pop         ecx  
00411620 89 4D F8         mov         dword ptr [ebp-8],ecx
35: 		cout<<"C-func"<<endl;
```

再看看4115E0的内容,实际上还是跳转到前面的41129E

[thunk]:C::func`adjustor{8}':
004115E0 83 E9 08         sub         ecx,8
004115E3 E9 B6 FC FF FF   jmp         C::func (41129Eh)
从汇编代码来看，C::AB:A:vftable[0]并没有用上，但是也被初始化了。
(所以结论是什么？？)


##	私有虚函数 和template method
**原来动态绑定可以不受private的影响(虚函数可以为private)**

这里有一片概要的介绍:
http://www.codeguru.com/forum/showthread.php?t=256624

私有虚函数的用途(参见设计模式-template method)
You use private virtual functions when you don't want anyone (including derived classes) to call the function directly (which should be most of the time, in a good, flexible design). You might use them when implementing the "Template Method" pattern.

Some people recommend that virtual functions should be private by default, and only protected and public if you have good reason. e.g. http://www.gotw.ca/publications/mill18.htm

主要目的,实现template method, 对外只提供固定的non virtual 接口。
不想别人直接调用虚函数

这个是C++和Java不一样的地方，其实我倒觉得Java的想法更合理一些。
因为private就不是接口了，任何接口都不是；protected对自己的继承类来说还是接口。Java就不允许private函数被override，因为它不是这个类的接口嘛。但C++可以。但是我自己写代码的时候不用private virtual，我用protected virtual，因为这样的意图更加清晰。
protected virtual允许非private继承的子类访问该protected函数。

其实template method （GoF）是用private virtual函数的好例子
```
class A {
public:
  void bar() {
    // initialize work, prepare
    foo();  // implementation delay to child class
    // post-work, it is like a template
  }
private:
  virtual void foo();
};

class B : public A{
private:
  virtual void foo();
};
```




# 初始化问题 

##	T a(v);和T a = v;的区别 netmd
关于 Copy-initialization
参考http://en.cppreference.com/w/cpp/language/copy_initialization

(NETMD) T a(v);和T a = v;的区别(难)
发信人: NetMD (见到了传说中的神！！), 信区: CPlusPlus
标题: [FAQ]T a(v);和T a = v;的区别
发信站: 水木社区 (Fri Mar 31 12:18:10 2006), 站内

本文所说的类型T均指UDT，非built-in类型
感谢ilovecpp，所有“*注”部分由他提醒而补充

构造一个对象，有如下三种形式：

1. T a;
这个没什么好说的，调用default ctor来构造a
不过要注意的是，要么T就一个ctor也没有，编译器合成default ctor，即T::T()
如果T有手动添加的其他形式的ctor，但是没有T::T()，则此语句报错，因为编译器不再
为T合成default ctor
*注1，如果没有default ctor，但是有某个ctor的所有参数都有缺省值，则T a;也成立


2. T a(v);
这个语句显式用v作为参数调用T的某个最适合的可单参数调用的ctor来构造a
该语句形式被C++标准称为direct-initialization
这里强调两点，一个是显式，这说明这种方式构造a的话可以调用被explicit声明的ctor
第二点是最适合，这是由overload rules决定的，而不是那么想当然，示例代码如下

```
struct T
{
  T(){}
  T(int){}
  operator int(){return 0;}
private:
  T(T&){}
};
T foo() {return T();}
int main()
{
  T a;
  T b(a);    // 编译出错，最适合的T(T&)不可访问，为private
  T c(foo());// 编译成功，foo()返回的临时对象是rvalue，不能绑定到non-const引用
 // 因此T(T&)不是由overload rules选定的最适合ctor
 // 但是rvalue可以调用一次自定义隐式转换cast到int然后调用T(int)构造c
 // 也就是说，overload rules选择了T(int)
   return 0;
}
```

这段代码说明，即使类型相同，调用的也不一定是copy ctor
如果有人怀疑T(T&)不是copy ctor，认为T(const T&)才是，请参阅C++标准12.8


3. T a = v;
该语句形式被C++标准称为copy-initialization，这个名称有很大的迷惑性，导致本人曾
一度认为该式语义上（稍后解释什么是语义上）必须要调用copy ctor
参照C++标准8.5/14，有这么一句话
```
If the destination type is a (possibly cv-qualified) class type:
  If the initialization is direct-initialization, or if it is
  copy-initialization where the cv-unqualified version of the
  source type is the same class as, or a derived class of, the
  class of the destination, constructors are considered. The
  applicable constructors are enumerated (13.3.1.3), and the
  best one is chosen through overload resolution (13.3). The
  constructor so selected is called to initialize the object,
  with the initializer expression(s) as its argument(s). If no
  constructor applies, or the overload resolution is ambiguous,
  the initialization is ill-formed.
```
简单点说，上面的意思就是，如果T是UDT，在“copy-initialization且v的cv-
unqualified类型也为T（或者T的派生类）”的情况下，执行方式同direct-initialization一样！
*注2，实际上该情况中的copy-initialization同direct-initialization还是有区别的，
**C++标准指出，只有T a(v);的方式才是显式调用ctor，否则为隐式调用，后者要求被选中的ctor不能被声明为explicit，否则编译出错**

C++标准12.3.1
```
*     An explicit constructor constructs objects just like non-explicit
*     constructors, but does so only where the direct-initialization
*     syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used.
```
C++标准还规定，如果非上述情况，则有
```
Otherwise (i.e., for the remaining copy-initialization cases),
  user-defined conversion sequences that can convert from the source
  type to the destination type or (when a conversion function is used)
  to a derived class thereof are enumerated as described in 13.3.1.4,
  and the best one is chosen through overload resolution (13.3). If the
  conversion cannot be done or is ambiguous, the initialization is ill-formed.
  The function selected is called with the initializer expression as its
  argument; if the function is a constructor, the call initializes a
  temporary of the destination type. The result of the call (which is
  the temporary for the constructor case) is then used to direct-initialize,
  according to the rules above, the object that is the destination of
  the copy-initialization. In certain cases, an implementation is permitted
  to eliminate the copying inherent in this direct-initialization by
  constructing the intermediate result directly into the object being
  initialized; see 12.2, 12.8.
```
简单点说，就是语句T a = v;在当v的类型不同于T（也不是T的派生类）的时候，语义上
要先用v构造一个临时对象T（或者调用自定义转换隐式cast到T类型或者T的派生类型），
然后显式调用copy ctor来构造a
之所以强调语义上，是因为标准说了这个调用可以优化掉，但是语义存在,而强调显式，则说明copy ctor可以为explicit
此外需要强调的就是虽然标准在这里说构造了临时对象T(v)之后（或者是将v隐式转换为类型T，static_cast<T>(v)）再用direct-initialize直接构造a，整个语句总的执行形式为T a(T(v));（static_cast<T>(v)用C语法也可记为T(v)），但是用T(v)所调用的ctor只能是T的copy ctor，原因是编译器已经进行了一次自定义的隐式转换T(v)，不能再进行第二次，所以必须调用对T(v)直接参数匹配的ctor，这就是copy ctor对上面的句子还有一个补充，就是派生类向基类的cast不算自定义隐式转换，是自动发生的，所以还有一种选择就是T a(U(v));而U是T的派生类！最终调用的仍旧是copy ctor示例如下
```
struct T
{
  T(){}
  T(int){}
  operator int(){return 0;}
private:
  explicit T(T&){}
};
int main()
{
  T a = T();  // 编译通过，相当于隐式调用T a(T());
              // 而重载规则选用了T(int)，即T a(static_cast<int>(T()));
// 如果T::T(int)声明为explicit，编译出错

  T b = 0;    // 编译出错，copy ctor不能访问，虽然被优化这个调用，但是语义尚存

  return 0;
}
```

下面再用一个示例补充说明
```
struct T
{
  T(int){}
  explicit T(const T&){}
};
void foo(T)
{
}
int main()
{
  foo(T(0)); // 编译出错，按照*注2，要求隐式拷贝给foo的参数
             // 相当于T t = T(0);

  foo(0);    // 编译通过，用0构造一个临时对象T(0)，然后显式拷贝给foo的参数
             // 相当于T t = 0;

  return 0;
}
```
由于函数的按值传参和按值返回都是copy-initialization，所以会有如上的结果差异
Gcc4.3即使是第二行也 编译不通过?!

## copy initializtion受到explicit ctor的限制
```
class AAA {
public:
    explicit AAA(const AAA&) {}
    AAA(int) {}
};


int main() {
    AAA a = 1;  // 这是copy-initialization
    return 0;
}
```
由于这个限制，无法编译:explicit 会限制copy-initialization，改成AAA a(1)可以
https://en.cppreference.com/w/cpp/language/explicit
Specifies that a constructor or conversion function (since C++11) is explicit, that is, it cannot be used for implicit conversions and copy-initialization.

参考
https://stackoverflow.com/questions/21822438/in-copy-initialization-is-the-call-to-the-copy-constructor-explicit-or-implicit

https://www.tutorialspoint.com/is-there-a-difference-between-copy-initialization-and-direct-initialization-in-cplusplus


**另一个例子**

```
struct T
{
  T(int){}
  explicit T(const T&){}
};
void foo(T)
{}
int main()
{
  foo(T(0)); //1 copy initialization?
  foo(0);    //2
  return 0;
}
```

为啥我用g++两个都编不过去。
参考前面netmd的文章
标准13.3.1.3 + 12.3.1.3
When objects of class type are direct-initialized (8.5), or copy-initialized from an expression of the same or a derived class type (8.5), overload resolution selects the constructor. For direct-initialization, the candidate functions are all the constructors of the class of the object being initialized. For copy initialization, the candidate functions are all the converting constructors (12.3.1) of that class. The argument list is the expression-list within the parentheses of the initializer.

构造函数隐式转换
CWG 152 说的是 foo(T(0)); 的情况..

引用如下，
```
152. explicit copy constructors
Section: 12.3.1  [class.conv.ctor]     Status: TC1     Submitter:
Steve Adamczyk     Date: 4 August 1999
Can a copy-constructor declared as explicit be used to copy class
values implicitly? For example,

struct X {
  X();
  explicit X(const X&);
};
void f(X);
int main() { X x; f(x); }
According to 12.3.1 [class.conv.ctor] paragraphs 2-3,
An explicit constructor constructs objects just like non-explicit
constructors, but does so only where the direct-initialization
syntax (8.5 [dcl.init] ) or where casts (5.2.9 [expr.static.cast] ,
5.4 [expr.cast] ) are explicitly used... A copy-constructor (12.8
[class.copy] ) is a converting constructor. An implicitly-declared
copy constructor is not an explicit constructor; it may be called
for implicit type conversions.
This passage would appear to indicate that the call in the example
is ill-formed, since it uses neither the direct-initialization
syntax nor an explicit cast. The last sentences are especially
interesting in this regard, indicating that explicit and non-
explicit copy constructors are handled differently.
On the other hand, 8.5 [dcl.init] paragraph 14, bullet 4, sub-
bullet 2 says,

If the initialization is direct-initialization, or if it is copy-
initialization where the cv-unqualified version of the source type
is the same class as, or a derived class of, the class of the
destination... [the] applicable constructors are enumerated
(13.3.1.3 [over.match.ctor] )...
The cited passage says that
The candidate functions are all the constructors of the class of
the object being initialized.
Notes from 04/01 meeting:

After the issue was accepted as a DR with the proposed resolution
to change 13.3.1.3 [over.match.ctor] paragraph 1 as described
below, it was noticed that 12.3.1 [class.conv.ctor] paragraph 3
states that:

A copy-constructor (12.8 [class.copy]) is a converting constructor.
In addition to making the proposed resolution for this issue
ineffectual, the wording of paragraph 3 also contradicts that of
paragraph 1:

A constructor declared without the function-specifier explicit that
can be called with a single parameter specifies a conversion from
the type of its first parameter to the type of its class. Such a
constructor is called a converting constructor.
These considerations led to the addition of the second point of the
proposed resolution.

Proposed resolution (04/01):

Change the first two sentences of 13.3.1.3 [over.match.ctor]
paragraph 1 to

When objects of class type are direct-initialized (8.5 [dcl.init]),
or copy-initialized from an expression of the same or a derived
class type (8.5 [dcl.init]), overload resolution selects the
constructor. For direct-initialization, the candidate functions are
all the constructors of the class of the object being initialized.
For copy-initialization, the candidate functions are all the
converting constructors (12.3.1 [class.conv.ctor] ) of that class.
Change the first sentence of 12.3.1 [class.conv.ctor] paragraph 3
to read:

A non-explicit copy constructor (12.8 [class.copy]) is a converting
constructor.
```

【在 skydoom (风险管理金融工程) 的大作中提到: 】
: 断章取义?
: CWG 152 提到的问题就是这个，所以C++ 03有了如上的修改。

总结，对于copy-initialization， 会受到explicit 的限制




#	构造函数/析构函数
##	概念
构造函数是不允许有返回类型，构造函数中没有虚函数机制，调用的过程是实际上会先调用基类的构造函数，再成员变量，最后是构造函数中的语句; 析构函数没有参数，也没有返回值

常见技巧
假如将构造函数声明为private,就是变相禁止该类被继承. 2010/01/07

一个隐式合成的构造函数，如果它没有虚函数，它的直接基类的构造函数是trivial的，所有的非静态成员都有trivial的构造函数，那么它就是trivial (C++ standard)->颇难理解->就是执行默认动作

派生类的构造函数总是试图去调用基类的默认构造函数（无参数的）构造函数, 如果基类没有合成默认构造函数，那么就无法编译通过。
```
struct base{
  base(int){}
};
Struct derived:base
{
Derived(){}//error这里无法通过编译，因为derived试图去调用base::base()，却没有这个函数.
//->
Derived():base(0){}//OK
};
```

这段话来自早期学习时的奇怪想法，留作纪念
构造函数也不会被继承，不能期望派生类没有构造函数时，定义一个派生类会自动调用基类的构造函数。(实际上编译器会为派生类尽量合成构造函数，并会调用基类的默认构造函数,2008/05/14) 派生类也只能调用其直接基类的构造函数->太过拗口，构造函数属于一种特殊的函数

**构造函数是否会被继承?不存在继承关系**
A->构造函数不允许是虚函数; 没有继承，当派生类中没有构造函数的时候，会调用了基类的构造函数(这是必然的，调用顺序先基类的构造函数->成员变量->派生类的构造函数)
例如base中定义了两个构造函数，但derived中没有定义，则用derived来声明一个对象时(指针对缺省构造函数)，会调用基类的构造函数；一旦显式的调用一个构造函数，均会检查它是否在这个类中真的存在。

## 初始化
在C语言中的全局变量和静态变量都是会自动初始化为0，堆和栈中的局部变量不会初始化，因此拥有不可预测的值。 C++保证了所有对象与对象成员都会初始化，但其中基本数据类型的初始化还得依赖于构造函数。

无论是trivial还是non-trivial的构造函数，都没有初始化成员变量？->C++标准是不会进行初始化动作

**{} 初始化**
Data test={"Final"};
must be initialized by constructor, not by `{...}'

但是用来初始化数组是可以的:
Data table[]={"zhou Rui","Qualsiode"};	
C11可以使用{}来初始化了


**声明指针和引用不会调用构造函数**
```
void passsth(resource &rhs){}//不会调用resource的copy ctor,any ctor
void passsth(resource rhs){} //调用copy ctor or ctor
```

静态成员变量必须在类之外被显式初始化，不能在构造函数中或初始化表中初始化，因为他们没有this指针。
通过指针new创建的对象，如果没有显式调用delete，是不会调用析构函数的，而local的对象，则会自动调用析构函数



析构函数必须为public吧，MCD中似乎有笔误了?待研究

**为什么arrays of references are illegal?**
http://stackoverflow.com/questions/1164266/why-arrays-of-references-are-illegal

##	合成默认构造函数／copy ctor／assignment
参见 https://www.cnblogs.com/QG-whz/p/4676481.html
以及 inside c++ object chapter5
只有几种情况会合成，类成员带有默认构造函数，基类有默认构造函数，自身或者基类带有虚函数

## explicit
Explicit会使编译严格检查构造函数的参数(应该是不允许编译期隐式转换对象)
Explicit 参考 CPP Primer P572
如C(B)，但是直接输入C(A)，A会隐式转为B，需要在B的ctor中explicit表明禁止隐式转为B.

参考MECPP中的条款5，用于禁止一些隐式的类型转换，特别是构造函数 A(int size)之类的转换
参考MECPP item 28,为何shared_ptr能禁止直接使用raw pointer赋值.
```
struct G
{
G(int){}	
};

G g1(1);
G g2 = 1;
```
如果改成
explicit G(int)
G g2 = 1;
无法通过编译.这个叫copy-initialization,可以参考NETMD写的文章


再考虑这个例子:
```
class MyData
{
public:
explicit MyData(int x){}
int x;
};
void explicit_test(MyData obj) {}

double x=0.1f;
explicit_test(x);
```
如果没有explicit,就能通过编译，否则通不过。

另一个例子:VS2013
```
class WDummy {
public:
explicit WDummy(const int &r) {
}
};
WDummy aw = i;
```
去掉explicit，则可以编译，否则出错.


##	Converting constructor 转换构造函数
一个non-explicit 的copy ctor是一个converting ctor
转换构造函数，可以通过下面方式构造
```
12.3.1  Conversion by constructor                    [class.conv.ctor]

1 A  constructor  declared  without the function-specifier explicit that
  can be called with a single parameter specifies a conversion from  the
  type  of  its  first  parameter to the type of its class.  Such a con-
  structor is called a converting constructor.  [Example:
          class X {
              // ...
          public:
              X(int);
              X(const char*, int =0);
          };
          void f(X arg)
          {
              X a = 1;         // a = X(1)
              X b = "Jessie";  // b = X("Jessie",0)
              a = 2;           // a = X(2)
              f(3);            // f(X(3))    **********
          }
   --end example]

12.3.1.3
  A non-explicit copy-constructor (12.8) is a converting constructor. An implicitly-declared copy constructor is not an explicit constructor; it may be called for implicit type conversions.
简单讲就是没有explicit的单参数copy ctor起到一种隐式类型转换的作用。

13.3.1.3 Initialization by constructor         [over.match.ctor]

  When objects of class type are direct-initialized (8.5), or copy-initialized from an expression of the same or a derived class type (8.5), overload resolution selects the constructor. For direct-initialization, the candidate functions are all the constructors of the class of the object being initialized. For copy-initialization, the candidate functions are all the converting constructors (12.3.1) of that class. The argument list is the expression-list within the parentheses of the initializer.
```
TODO
有空翻译一下

## 为何定义虚析构函数
EFC 07 说基类带有虚函数，带有虚函数就应该定义虚析构函数。如果基类没有虚函数呢，还能作为基类(是基类)吗？还需要定义虚析构函数吗，没有定义的话有没有内存泄露？
string 可以继承，但是string没有虚析构函数，当delete base_ptr时可能行为不当？
TODO 能否继承STL
```
class I32Base {
public:
	void *operator new (size_t size){
		std::cout << "I32 base\n";
		return ::operator new (size);
	}
	~I32Base() {
		std::cout << "I32 base dtor\n";
	}
};

class I32Child : public I32Base {
public:
	void *operator new (size_t size){
		std::cout << "I32 child\n";
		return ::operator new (size);
	}
	I32Child() {
		void *ptr = malloc(5);
	}
	~I32Child() {
		std::cout << "I32 child dtor\n";
	}
};

void i32() {
	//I32 *i32 = new I32();
	//delete i32;
	//I32Child *ptr = new I32Child();
	I32Base *ptr = new I32Child();
	delete ptr;
}
```

这里只会调用I32Child 的operator new,base不会调用
I32Child *ptr = new I32Child();

没有定义virtual dtor in base class, derived class中的dtor没有被调用，内存泄露。
所以标准应该是基类(不特指带虚函数的基类)？？


##	纯虚析构函数/纯虚函数
如果派生类没有对基类的pure-virtual func进行override的话，那么这个基类就仍然是abstract的

为什么需要纯虚析构函数？使其为抽象类无法实例化，如果正好没有其他的纯虚函数，那只好使用纯虚析构函数，不过这种情况少之又少。(很少有抽象类只有一个纯虚析构函数.)
最常见的情形，有了其它的纯虚函数，要不要把虚析构函数也实现为纯虚函数？(应该不需要)
参考http://www.gotw.ca/gotw/031.htm
There are three main reasons you might do this. #1 is common place, #2 is pretty rare, and #3 is a workaround used occasionally by advanced programmers working with weaker compilers.
All base classes should have a virtual destructor (see your favourite C++ book for the reasons). If the class should be abstract (you want to prevent instantiating it) but it doesn't happen to have any other pure virtual functions, a common technique to make the destructor pure virtual:
```
    // file b.h
    class B {
    public: /*...other stuff...*/
        virtual ~B() = 0; // pure virtual dtor
    };
```
Of course, any derived class' destructor must call the base class' destructor, and so the destructor must still be defined (even if it's empty):
```
    // file b.cpp
    B::~B() { /* possibly empty */ }
If this definition were not supplied, you could still derive classes from B but they could never be instantiated, which isn't particularly useful.
```
即使声明为纯虚函数，还是要有definition（body),因为子类会析构的时候，必然通过chain来调用父类的析构函数，如果不存在，那么就会有runtime unreference error. Link 错误

这个声明会有编译错误:error: pure-specifier on function-definition
```
class base {
 public:
  virtual ~base() = 0 {};
};


实现:
class A {
virtual ~A() = 0;
};

inline A::~A() { }
```
其它的纯虚函数可以没有body,但是pure virtual dtor没有body的话会说link有问题。
没使用类的时候可以通过编译，当使用的时候:
```
I33child2 *child2 = new I33child2();报告
无法解析的外部符号 "public: virtual __thiscall I33base2::~I33base2(void)" (??1I33base2@@UAE@XZ)
这个语句并没有call dtor,为何会有该warning?推测->这个语句触发生成I33child2的代码，在I33child2的dtor里，需要call I33base2的dtor,找不到，因此有link error.

class I33base2{
public:
	virtual int foo(float x) = 0;
	virtual ~I33base2() = 0 {};
};

class I33child2 : public I33base2{
public:
	virtual int foo(float x){ return 0; }
};
即使有了body,也不允许实例化I33base2 的对象.
```

## 在构造/析构函数里调用虚函数
那么在构造函数里调用虚函数有什么结果,看看耐人寻味的这段代码(by rz)
```
#include "stdafx.h"
class base
{
public:
  virtual void func(){
    int c=1;
  }
  base(){
    func();
  }
};

class derived:public base
{
public:
  derived(){
    func();
  }
  void func() {
    int b=1;
  }
};
int _tmain(int argc, _TCHAR* argv[])
{
  base *p=new derived();
  return 0;
}
```
结果:Base:func和derived:func都会被调用到，因为在调用base:ctor的时候,this是base,而derived:ctor的时候,this是derived，这个时候可以看到未全部构造完毕前,this里vtable是变化的.就是虚函数不会作为虚函数使用。
```
class A{
public:
  virtual void f()=0;
  void g(){f();}
  A() {
    f();
    g();
  }
};
int main() {
  return 0;
}
```
在构造函数里调用纯虚函数是禁止的(无法),然而却不能阻止这样的情况（间接）
```
class A{
public:
  virtual void f()=0;
  virtual void g(){f();} //通过g()隐式的调用了f()
  A()
  {
    //f();
    g();
  }
};
int main()
{
  return 0;
}
```
## 为什么构造函数不能是虚函数(虚拟构造函数)
现在有一种流行的虚构造函数，实质就是clone，类厂方法/2010/01/06
例如
```
Class Foo
{
Public:
  Static Foo* clone(int parameter){return new Foo();}
};
```

## delete[]
C++primer,p630,缺少[]可能导致只在首元素上调用dtor,尽管释放的内存量可能是正确的,delete[]为每一个成员调用了dtor.


3.3.4	delete this 合法吗？
Q39：成员函数做 "delete this" 的动作是合法的（并且是好的）吗？
只要你小心的话就没事。->另一个地方说不太好
我所谓的「小心」是：
  1) 你得 100% 确定 "this" 是由 "new" 配置来的（而非 "new[]"，亦非自订的
     "new" 版本，一定要是最原始的 "new"）。
  2) 你得 100% 确定该成员函数是此物件最後一个会呼叫到的。
  3) 做完自杀的动作 ("delete this;") 後，你不能再去碰 "this" 的物件了，包
括资料及运作行为在内。
  4) 做完自杀的动作 ("delete this;") 後，你不能再去碰 "this" 指标了。
换句话说，你不能查看它、将它与其他指标或是 NULL 相比较、印出其值、
对它转型、对它做任何事情。
很自然的，这项警告也适用於：当 "this" 是个指向基底类别的指标，而解构子不是
virtual 的场合。

## 构造函数的一种优化
```
class test2
{
public:
  int y;
  test2(int ui) : y(ui){}
  test2(const test2& t) : y(5){}
  test2& operator= (const test2& t){ y = 6; return *this; }
};

int main()
{
  //test2 t2(test2(20));
  test2 t2 = test2(20);
  cout << t2.y << endl;
  derived d;
}
```
没看懂优化在哪里

## 析构函数为private
异常处理体系要求栈中对象的dtor必须为公有。
声明dtor 为private往往是不合理的

## 如何显式的调用基类的构造函数？
基类B中有某构造函数fB，但派生类D中没有实现该构造函数，假如这样声明:D obj(fB…)的话，编译器报错，如何改正？
(构造函数是无法继承的，它不会被隐式的调用基类的构造函数，这不是一个概念，可以在派生类的构造函数初始化成员表中选择调用基类的某个构造函数，顺序，基类构造函数->成员初始化表->派生类的构造函数)


## 编译器默认实现的函数
参看EMC #17
构造函数Data()，拷贝构造函数Data(&Data)，析构函数~Data()，赋值函数?



# 其它成员
## Const及成员变量初始化
类中有const成员时必须进行初始化?->必须在”成员初始化表”中初始化(构造函数后面跟着的初始化表)，不能在构造函数中初始化const变量在declare后必须被define(初始化),成员初始化的顺序按照类中定义的顺序

## 禁止copy ctor & assignment 
http://blog.csdn.net/vgxpm/article/details/42317595
知道禁用 copy-ctor/assign operator 是 C++ 程序员的试金石。在看到一个开源项目时，先查看其 RAII handle class 是否禁用了 copy-ctor/assign operator（例如 Thread、Mutex、CondVar、Connection），如果没有，对其第一印象就很差了。
进行类体设计时，会发现某个类的对象是独一无二的，没有完全相同的对象，也就是对该类对象做副本没有任何意义．
因此，需要限制编译器自动生动的拷贝构造函数和赋值构造函数．一般参用下面的宏定义的方式进行限制.

```
public:
	promise(constpromise&) = delete;
	promise& operator=(constpromise&) = delete;
```
这样可以阻止声明为成员变量？




## 赋值操作符
当定义String的operator=的时候，如下两个函数
String& operator=(String &rhs) {}
String& operator =(const String &rhs) {}
会产生warning “it::String”: 指定了多个赋值运算符

参考http://en.cppreference.com/w/cpp/language/as_operator
```
SYNTAX

class_name & class_name :: operator= ( class_name )	(1)								

class_name & class_name :: operator= ( const class_name & )	(2)								

class_name & class_name :: operator= ( const class_name & ) = default;	(3)	(since C++11)							

class_name & class_name :: operator= ( const class_name & ) = delete;	(4)	(since C++11)							

EXPLANATION
1.	Typical declaration of a copy assignment operator when copy-and-swap idiom can be used
2.	Typical declaration of a copy assignment operator when copy-and-swap idiom cannot be used
3.	Forcing a copy assignment operator to be generated by the compiler
4.	Avoiding implicit copy assignment
```





## 名字查找
使用后又被重新定义，非法-Andy Koening
const int i =9;
class Z
{
  int a[i];
  int f(){return i;}
  enum {i=1}; //error: changes meaning of ‘i’ from ‘const int i’ [-fpermissive]
}
这段代码在vc中却是有效的.因为在不同的命名空间全局 vs 类内部
写到一起就不行了



##	类声明内直接赋值 tbd
```
class I26Base {
public:
    const int count = 10;
};
```
必须是const,enum等不可变变量
而c++11中允许直接赋值了



##	函数的参数是一个临时变量
[D&E]
禁止非左值被一个非const 引用初始化
原因：非左值，即临时变量，把它赋给一个非const的引用，而非const的引用可以被修改，实际上修改的是临时变量。

类似的观点 : [MEC] 禁止为非常量引用产生临时对象这句话的出处
另外也有人质疑:
void fn(string&) {} //非常量引用
fn(string("a"));       //产生了临时对象

gcc 3.2.3编译不能通过，VS 2005编译能通过。(因为VS将其看作language extension)

以及这个例子,GCC是认为错误的:
返回函数内的临时变量
class X{};
X func2(){return X();}
void g1(X&){}
void g2(const X&){}
int test_const()
{
    g1(func2() );//不可以,但是VC作为一个extension
    g2(func2() );//可以，const
}

还有一个例子:
error: invalid initialization of non-const reference of type '   char*&' from a temporary of type 'char*'
error: in passing argument 1 of `void decode(char*&)'
char gbuf[64]="abcdefg";
char *getPayload()
{
  return &gbuf[1];
}
void decode(char *&ptr)
{
  ptr+=1;//大概意思是初始化这个这个non-const reference ptr的时候出问题，它是从一个temp char*初始化的.
  printf("%s\n",ptr);
}
Int main()
{
  decode(getPayload());
}


《C++程序设计语言》（特别版）的10.4.10 临时对象一节说：可以用临时对象作为const引用或者命名对象的初始式。可以通过显示地调用构造函数的方式建立临时对象。我觉得VS 2005能编译通过是不对的。

## 访问基类的成员(友元TBD)
```
class ExBase
{
private:
	static int stat;
public:
	int m_base;
	static int GetStat(){ return stat; }
};
int ExBase::stat = 25;
class ExDer1 : public ExBase
{
public:
	friend int Der1Fn(){ return ExBase::stat; }
	void access() {
	  std::cout << ExBase::m_base << std::endl;  //在内部可以这样
	}
};
class ExDer2 : public ExBase{};
class ExDer : public ExDer1, public ExDer2{};

void friendtest() {
	std::cout << ExDer1::ExBase::GetStat() << std::endl;
	ExDer1 d1;
	//std::cout << d1::ExBase.m_base << std::endl;在外部不可以这样，直接访问
}
```
TODO 上面这个看的有点糊涂,这不是一个diamond inheritence，对ExBase的定义应该有重复的




VS2005提供了

参考More effective C++ item 20










1.4	名字改编和调用约定
以vc为例，
1. c和c++之间：
void foo(int x, int y);
该函数被C编译器编译后在库中的名字为_foo,而C++编译器则会产生像_foo_int_int
之类的名字用来支持函数重载和类型安全连接.由于编译后的名字不同,C++程序不能
直接调用C函数.C++提供了一个C连接交换指定符号extern"C"来解决这个问题.
2。不同编译器之间：
即使是按照c链接，但是不同的调用约定，比如__stdcall 和 __cdecl调用也会产生不同的名字改编。

关于调用约定

调用约定堆栈清除参数传递
  __cdecl      调用者从右到左,通过堆栈传递
  __stdcall    函数体从右到左,通过堆栈传递
  __fastcall   函数体从右到左,优先使用寄存器(ECX,EDX),然后使用堆栈
  thiscall     函数体    this指针默认通过ECX传递,其它参数从右到左入栈
note：
（1）__cdecl是C\C++的默认调用约定;
VC的调用约定中并没有thiscall这个关键字,它是类成员函数默认调用约定;
C\C++中的main(或wmain)函数的调用约定必须是__cdecl,不允许更改;
默认调用约定一般能够通过编译器设置进行更改,如果你的代码依赖于调用约定,请明确指出需要使用的调用约定;
（2）常见的函数调用约定中,只有cdecl约定需要调用者来清除堆栈;C\C++中的函数支持参数数目不定的参数列表,比如printf函数;由于函数体不知道调用者在堆栈中压入了多少参数,所以函数体不能方便的知道应该怎样清除堆栈,那么最好的办法就是把清除堆栈的责任交给调用者;这应该就是cdecl调用约定存在的原因吧;

C编译在进行编译的时候也会进行名字的改编，当函数使用_stdcall(WINAPI)调用规则时，MS编译器就会改编函数的名称。
比如：__declspec(DLLexport) LONG __stdcall Proc(int a ,int b);
编译器会改编为__Proc@8
因此当非C++或非C编译器调用该DLL中的函数Proc时，就会出现找不到函数的情况。
这样我们就可以定义DEF文件来解决，并且在DEF文件加上下面的EXPORTS：
EXPORTS  Proc
Def模块执行原理：当连接程序分析这个DEF文件时，它发现Proc和__Proc@8都被输出，由于这两个函数是相互匹配的，因此连接程序使用Proc来输出该函数，根本不使用__Proc@8来输出函数名
(3)下面是
调用习惯　VC++命名       C++Builder命名

__stdcall  _MyFunction@4  MyFunction
__cdecl    MyFunction     _MyFunction
可以从网上搜索“在C++Builder里创建可以被Visual C++使用的DLL”以及“Using Visual C++ DLLs in a C++Builder Project”这两篇文章，看看不同编译器生成的dll之间是如何互相调用的。

1.5	.Inline
inline 一定是声明后紧跟函数定义，否则会出现unsolved symbol, 构造函数默认是inline ?
在(头文件)类声明中如果定义了函数，那么通常能够被inline

static inline 函数称为：静态内联函数 。 它不使用函数调用，直接将汇编代码插入在调用该函数处。
GCC的static inline定义很容易理解：
    你可以把它认为是一个static的函数，加上了inline的属性。这个函数大部分表现和普通的static函数一样，只不过在调用这种函数的时候，gcc会在其调用处将其汇编码展开编译而不为这个函数生成独立的汇编码。除了以下几种情况外：取函数地址和递归调用
实际上和普通inline差不多，就是静态(局限在编译单元里)

Inline函数中含有static 变量怎么办
static 变量是放在全局数据区并且是唯一的，inline函数并不会改变这个特点，因此多个调用inline函数的地方仍然会只有一个static 变量

1.6	Static变量/函数
static 声明的变量在C语言中有两方面的特征

变量会被放在程序的全局存储区中，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。

变量用static告知编译器，自己仅仅在变量的作用范围内可见(即编译单元，每一个cpp文件都是一个编译单元)。这一点是它与全局变量的区别。如果静态变量放在头文件里，那么每个包含了该头文件的cpp文件所形成的编译单元中都有一份该变量，事实上造成浪费。是否会冲突？

函数声明为static的作用？
kernel的代码中，很多变量和函数都定义为static形式，这是为了尽量不影响全局命名空间。但是EXPORT_SYMBOL输出的变量和函数就需要注意了，不能随大流也定义为static。因为如果定义为static的输出符号模块被编译进kernel，调用该符号的地方就会出现链接错误，符号没有被加到全局符号空间。
函数声明为static的话，将函数的范围限制为该文件内

可以通过Class::static_variable和obj.static_variable两种形式来访问

基类中声明了静态变量，派生类中访问静态变量的话，实际上访问的是同一份实例，整个环境内都只有这个实例
class I26Base {
public:
    static int count;
    I26Base() {
        count++;
    }
};
int I26Base::count = 0;

class I26Child : public I26Base {
public:   
};

类的静态函数可以通过对象访问的，指针也可以.调用时遵从普通函数的绑定规则，依赖于调用对象/指针来决定实际的调用函数。


1.7	函数模板
如果函数中没有传递进任何参数，那么就无法deduce 出模板来

5	多维/数组，对象数组
5.1	多维数组
int arr[row][col]={{row0},{row1}}
int arr[][2] = {(1,2,3),(4,5,6)}  这种方式实质上是逗号运算符，等于{3,6}
int dx[]={-1,1,0,0};  //x-axis left,right,up,down  可以在函数内声明，但不可以在in-class initializer
https://stackoverflow.com/questions/29593207/what-is-the-reason-for-not-being-able-to-deduce-array-size-from-initializer-stri/29593683

5.2	size的声明
函数调用方法可以参考morgan的一道题，但是注意这个：
int a[2][2]={{1},{2,3}}; a[0][1]=0  因为用括号括起了

C++98要求必须用整型字面值，常量，枚举常量来作为数组的维数
C99/GCC允许以下做的扩展
int n = 2;
int myarr[n];

5.3	对象数组初始化
如果没有默认构造函数，无法直接声明对象数组：Knot obj[100];

初始化:
C++98支持此种方式
class MyClass {
public:
MyClass(int numl) {
std::cout << num << "," << val << std::endl;
}
};
MyClass array[2] = {1, 2};

但如果ctor接受两个参数，则无法如下初始化
MyClass array[2] = { { 1, 2 }, { 1, 3 } };
这个是C++11的initializer list的做法

部分初始化必须有默认构造函数
MyClass array[2] = { {0,1} }; // {}
可以不使用=
MyClass array[2] { {0, 1}, {4,5} };
禁止缩窄转换，例如float->int

二维数组
Int arr[10][20],内存上是这样排列的先0..20,再第二个0..20,重复10次	

不存在[][]的重载函数，但可以使用一个proxy对象来实现，参考MEFC30


#	指针
##	指向数组的指针和指针数组
参考http://msdn.microsoft.com/en-us/library/ms859264.aspx

int *var[5]; /* Array of pointers to int values */ 指针的数组

The array modifier has higher priority than the pointer modifier, so var is declared to be an array. The pointer modifier applies to the type of the array elements; therefore, the array elements are pointers to int values.

int (*var)[5]; /* Pointer to array of int values */ 指向数组的指针

试题:
int *(*p)[5];指向数组5的指针的指针
Which  of  the  following  statements  can  be  used  to  allocate  memory  for  the  first 
dimension in order to make p an array of 3 arrays of 5 pointers to type int?

p = new int *[3][5];

初学者总是分不出指针数组与数组指针的区别。其实很好理解：
指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身决定。它是“储存指针的数组”的简称。
数组指针：首先它是一个指针，它指向一个数组。在32 位系统下永远是占4 个字节，至于它指向的数组占多少字节，不知道。它是“指向数组的指针”的简称。

下面到底哪个是数组指针，哪个是指针数组呢：
A)
int *p1[10]; 指针的数组, 10个元素，每个都是指针
B)
int (*p2)[10]; 数组的指针
每次上课问这个问题，总有弄不清楚的。这里需要明白一个符号之间的优先级问题。

“[]”的优先级比“*”要高。p1 先与“[]”结合，构成一个数组的定义，数组名为p1，int *修饰的是数组的内容，即数组的每个元素。那现在我们清楚，这是一个数组，其包含10 个指向int 类型数据的指针，即指针数组。至于p2 就更好理解了，在这里“（）”的优先级比“[]”高，“*”号和p2 构成一个指针的定义，指针变量名为p2，int 修饰的是数组的内容，即数组的每个元素。数组在这里并没有名字，是个匿名数组。那现在我们清楚p2 是一个指针，它指向一个包含10 个int 类型数据的数组，即数组指针。我们可以借助下面的图加深理解

总结，是否先结合[]，先结合[]形成一个数组，然后再看数组里面是什么

##	函数指针
```
Class Result;
typedef Result (*FuncPtr)();
// 定义FuncPtr为一个指向函数的指针类型。这种函数无参数，返回Result。
typedef int p(); //定义了一个int p(){} 的函数
```
**成员函数指针**
声明: int (*comp)(void *, void *)
typedef void (Person::*PPMF)();//
void (PPP::* retPPMF () ) ()


在类中这样定义:
void (Person::* verificationFunc())() {return &Person::verifyAddress;}
或者这样:
PPMF verificationFunc() {cout<<"verify"<<endl;return &Person::verifyAddress;}

调用：
Person scott;
PPMF pmf = scott.verificationFunc(); //指针赋值
(scott.*pmf)(); //调用，看起来像是类的成员

静态成员的指针就和全局成员一样，静态成员没有”this”指针


## 从语句 char* p="test" 说起[zz]

char buf[256]=”abcdefg”;实际上定义的是一个const char* ?
我相信，使用C/C++多年的人对下面这个字符串赋值语句都不会陌生吧。
```
char* p = "test"; // const char *p="test
```

同时，我也相信，各位在使用这种语句后吃过很多苦头也不少吧？只要你想利用指针p来改变字符串的内容，你的程序都会得到一个让你颜面尽失一个内存非法操作。比如，下面的这些语句：
```
p[0] = 's';
strcpy(p, "haoel");
```

原因就在于，char* p = "test"; 这个声明，声明了一个指针，而这个指针指向的是全局的const内存区，const内存区当然不会让你想改就改的。所以，如果你一定要写这块内存的话，那就是一个非常严重的内存错误。另，之所以加粗“全局const内存区”，是强调一下，如果你不信的话，你可以试试下面这段代码，看看p1和p2的地址是不是一样的。
```
char* p1 = "anything";
char* p2 = "anything";
printf(“ p1=%x, p2=%x \n”, p1, p2); //地址是一样的，因为编译器为他们分配了存储空间
```

我想这应该是一个众所周知的问题吧。取而代之的，应该是使用数组来做初始化声明。如：char str[] = “hello world”; 如果现在还有哪本书中的C的示例采用了使用const字符串初始化指针的这种方式，那么你就可以把那本书撕了，如果这本书是C++的书话，那么你应该把这个作者和这个出版社告上法庭，因为你不应该容忍这种学术骗子。如果你的部门的开发人员还有人写出这种代码的话，如果他是C程序员，我想你可以在打过他的屁股后告诉他下不为例，如果他是一个C++程序员的话，我想你可以怀疑他是否有资格做一个C++程序员了。

至于你问我为什么要对学C++的人那么苛刻，那是因为学过C++的人都知道C++中的const关键字的有着什么样的权力，你也应该知道C++对const有着无比的照顾和关爱，几乎所有关于C++的书都会提到const这东西。所以，如果作为一个C++的程序员来说，如果你不知道的话，那就太说不过去了。

我们知道，双引号引起来的字符串是const的，所以，在C++的世界中，你应该进行如下的声明才比较稳妥：
```
const char *p = "test";
```

这样，当你修改这个字符串的内容时，编译器会给你一个错误而导致你的程序编译不通过，从而不会产生运行时的内存错误。

可问题是，像C++这种对类型要求很严格的语言来说，为什么它在编译诸如char *p="test" 程序的时候不出错，甚至连个警告都没有（g++和vc++7）？难道这是他的一个bug？我想，这应该是对古老的C的一个向下兼容。因为，在C的世界中，这种用法太多了。

在C++中，比如：函数的参数和异常的捕获都存在这种问题，如下所示：（因编译器而定，在gcc 3.4.3版中，下例中的异常示例不能被捕获，但VC++6中却可以被捕获）
```
func( char* p) { }    // 以这种方式调用函数func(“abc”);
try { thow “exception”; } 
catch (char* p) { } //const char*->char*
```
这些都是C++编译器默认了可以把const char* 转成 char*的罪行，无疑会对大家是一个误导。甚至让人无所畏惧地走入其中，并自以为走入了正途。这样看来，这种向下兼容的C++标准，就显得有点误人不浅了。

不过好在，C++标准委员会早已意识到了这一点。这个C++的feature被定义为了“Deprecated Feature”，即“不被建议使用的特性”。意思就是，在将来，这种特性将被从C++中移出，于是，你目前的这种程序将无法在新的C++编译器上编译通过。对于程序的可移植性来说，我们今天所写的代码尤其要注意这些“Deprecated Feature”。

据我所知，目前C++中被列为“Deprecated Feature”如下所示（可能不准确，请大家指正）下面的这些feature都已被C++标准委员会订为废除featrue了。

一、隐晦的字符串的const转换。

char *p = "test";
w_char *pw = L"test";

把一个const的字符串类型转成non-const的。包括指针和数组。

二、隐晦的类型声明。

func() {}    //函数的隐晦返回类型是int
static num;     //变量的隐晦类型是int
这种feature在C89中还可以使用，但在C99和C++中都被去除了。（gcc 3.4版本对于这种声明会给出编译错误，而VC++6.0会认为这是合法的程序）

三、布尔变量的累加操作。
bool isConn = false;
isConn++;           //这个操作会把isConn变为true
就目前而言，几乎所有的编译器都认可这种操作，但这种用法也是不被建议的，终有一天会被取消。

四、更改父类成员的存取权限。
```
class B
{
protected:
  int i;
};

class D : public B
{
public:
  B::i; //这种方式可能大家很少看到。
};
```

对于这种语法，子类重新暴露了父类的私有成员。这会带来很大的安全性问题。目前而言，这个feature对于所有的编译器来说应该都是可以编译通过的（连个Warning都没有）。但这个feature也是要被废除的。

五、文件中域的static声明
```
static int i;
static void func()
```

据说，这种旧的在C中的为了实现其作用域在本文件中的feature在未来的C++中也要被取消。

文章到这里应该结束了，在结束之前，让我再给大家共享一个有趣的关于const的例子（在网上看到的）
```
const int a = 1;
int *p = const_cast<int*>(&a);
*p = 2;

cout << “value a=”<< a << endl;
cout << “value *p=” <<*p << endl;
cout << “address a=” <<&a << endl;
cout << “address p=” <<p << endl;
```
这段代码输出的结果如下：

value a=1
value *p=2
address a=0xbff1d48c
address p=0xbff1d48c

地址都是一样的，可值为什么不一样呢？呵呵。这个问题看起来有点“学术味”过浓，不过是个好例子，可以让你知道C++的一些用法和一些原理。有以下几个方面大家可以考虑一下：
1）const int a = 1是不是和宏有点像，会不会被编译器优化了？
2）去修改一个const的值，本来应该是不对的。这可能会是向旧的C兼容。是否会让编译器产生未知行为？

所以，这个示例也告诉我们，我们应该遵循C++中的const和non-const的语义，任何想要破坏这个语义的事情都会给我们带来未知的结果。

## 数组能否传递给作为&的参数
另外：[more effectice c++ item19]

在more effective C++上看到的，可是在标准里粗略找了一下没找到，在哪里呢？
```
void uppercasify(string& str) // 把str中所有的字符改变成大写
{
}
char subtleBookPlug[] = "Effective C++";
uppercasify(subtleBookPlug); // 错误!
```
不解:
如果这样用不也是产生临时对象吗？
uppercasify(string("subtleBookPlug"));


#	类型转换
## K&R C和ANSI C两种风格的函数声明(过时)
K&R C和ANSI C两种风格的函数声明及定义在参数类型隐式转换上的区别
K＆R C的函数声明：
function();
这种方式声明的函数，在向其传递参数时，较小类型的参数会被进行隐式类型转换，如char、short被转换为int，float被转换为double。即堆栈中所存储的参数其所占字节数大于实际应该占用的字节

所以int -> double, char->int

ANSI C的函数声明：
int function( char c, short si, float f )
这种方式声明的函数，在向其传递参数时，不会发生隐式类型转换，堆栈中各个参数所占字节就是各个类型的实际应该占用的字节。


K＆R C的函数定义：
function()
char c;
short si;
float f;
{}

这种方式定义的函数，其参数在使用时，会先按被隐式类型转换之后的大小，从堆栈中提取出来，然后再按函数定义中的实际类型进行截取。如，char类型变量c实际访问时，先在堆栈中变量c的存储位置，提取出一个int大小的“临时变量”，然后将该“临时变量”截取成一个char变量再进行运算。short及float变量同理。


ANSI C的函数定义：
int function( char c, short si, float f )
{}
这种方式定义的函数，其参数使用时，直接从堆栈中按实际定义的大小进行提取即可。


故K＆R C和ANSI C的函数声明及定义，在参数类型转换上的区别可分为两个部分：
1. 在参数传递给该函数时，是否发生了类型提升？K＆R C有类型提升，ANSI C没有
2. 在函数实际使用其参数时，是否发生了字节截取？K＆R C有，而ANSI C没有
因此，代码中对同一个函数的声明和定义，必须使用一致的风格，不可混用K＆R C和ANSI C风格。


## C++类型转换

参考more effecrtive c++ item2

dynamic_cast,虽然是一种’可靠’的转换，但会带来开销，避免使用
static_cast (主要是向上转换，向下转换的时候会判断是否有继承关系，没有关系的在compiler期就会失败)
const_cast 将const 的指针转成非const时要使用这个
reinterpret_cast是一种强制转换，系统不会重新计算指针的位置，他只是将当前指针的地址，直接转为新的指针，避免使用这种转换

例子：
```
class A{int ai;};

class C{int ci;};

class B:public A,public C
{int bi;};

int _tmain(int argc, _TCHAR* argv[])
{
	B b;
	A *pa = &b;
	C *pc = &b;
	return 0;
}
```

可以看到:pa指向了B中的A子对象的地址，而pc指向了B中C子对象的地址(确实，编译器已转换)
再看看反过来的情况:
```
int main() {
	A a;
	A a_tmp;
	C c;
	a.ai=3;
	a_tmp.ai=4;
	c.ci=5;
	B *pba = static_cast<B*>(&a);//必须用static_cast或强制转换，否则无法通过编译，这个转换有问题，居然通过编译??向下可以? 
	B *pbc = static_cast<B*>(&c);//same
	return 0;
}
```

可以看到这样强制转换之后pba中的C子对象实际上指向了a_tmp，所以说用向下转换是不安全的.(纯粹基于offset运算)

## 补充阅读-C++类型转换
### static_cast Operator 静态转换

MSDN:
The expression static_cast < type-id > ( expression ) converts expression to the type of type-id based solely on the types present in the expression. No run-time type check is made to ensure the safety of the conversion.


Syntax
static_cast < type-id > ( expression )
The static_cast operator can be used for operations such as converting a pointer to a base class to a pointer to a derived class. Such conversions are not always safe. For example:

```
class B { ... };
class D : public B { ... };
void f(B* pb, D* pd)
{
   D* pd2 = static_cast<D*>(pb);   // not safe, downcast
   B* pb2 = static_cast<B*>(pd);   // safe conversion
}
```

In contrast to dynamic_cast, no run-time check is made on the static_cast conversion of pb. The object pointed to by pb may not be an object of type D, in which case the use of *pd2 could be disastrous. For instance, calling a function that is a member of the D class, but not the B class, could result in an access violation.

>在编译时检查，不匹配(不存在继承关系)的typeid将无法通过编译.但是会存在向下转型的问题,downcast,没有运行时检查,所以无法确认真实的对象

The dynamic_cast and static_cast operators move a pointer throughout a class hierarchy. However, static_cast relies exclusively on the information provided in the cast statement and can therefore be unsafe. For example:
```
class B { ... };
class D : public B { ... };

void f(B* pb)
{
  D* pd1 = dynamic_cast<D*>(pb);
  D* pd2 = static_cast<D*>(pb);
}
```

If pb really points to an object of type D, then pd1 and pd2 will get the same value. They will also get the same value if pb == 0.
If pb points to an object of type B and not to the complete D class, then dynamic_cast will know enough to return zero. However, static_cast relies on the programmer’s assertion that pb points to an object of type D and simply returns a pointer to that supposed D object.
Consequently, static_cast can do the inverse of implicit conversions, in which case the results are undefined. It is left to the programmer to ensure that the results of a static_cast conversion are safe.
This behavior also applies to types other than class types. For instance, static_cast can be used to convert from an int to a char. However, the resulting char may not have enough bits to hold the entire int value. Again, it is left to the programmer to ensure that the results of a static_cast conversion are safe.
The static_cast operator can also be used to perform any implicit conversion, including standard conversions and user-defined conversions. For example:

```
typedef unsigned char BYTE
void f()
{
  char ch;
  int i = 65;
  float f = 2.5;
  double dbl;

  ch = static_cast<char>(i);            // int to char
  dbl = static_cast<double>(f);         // float to double
  i = static_cast<BYTE>(ch);
}
```

The static_cast operator can explicitly convert an integral value to an enumeration type. If the value of the integral type does not fall within the range of enumeration values, the resulting enumeration value is undefined.
The static_cast operator converts a null pointer value to the null pointer value of the destination type.
Any expression can be explicitly converted to type void by the static_cast operator. The destination void type can optionally include the const, volatile, or __unaligned attribute.

The static_cast operator cannot cast away the const, volatile, or __unaligned attributes.

> static_cast在功能上基本上与C风格的类型转换一样强大，含义也一样。它也有功能上限制。例如，你不能用static_cast象用C风格的类型转换一样把struct转换成int类型或者把double类型转换成指针类型，另外，static_cast不能从表达式中去除const属性，因为另一个新的类型转换操作符const_cast有这样的功能。

### const_cast Operator
MSDN:
The const_cast operator can be used to remove the const, volatile, and __unaligned attribute(s) from a class.
Syntax
const_cast < type-id > ( expression )
A pointer to any object type or a pointer to a data member can be explicitly converted to a type that is identical except for the const, volatile, and __unaligned qualifiers. For pointers and references, the result will refer to the original object. For pointers to data members, the result will refer to the same member as the original (uncast) pointer to data member. Depending on the type of the referenced object, a write operation through the resulting pointer, reference, or pointer to data member might produce undefined behavior.
The const_cast operator converts a null pointer value to the null pointer value of the destination type.

>const_cast用于类型转换掉表达式的const或volatileness属性。通过使用const_cast，你向人们和编译器强调你通过类型转换想做的只是改变一些东西的constness或者 volatileness属性。这个含义被编译器所约束。如果你试图使用const_cast来完成修改constness 或者volatileness属性之外的事情，你的类型转换将被拒绝。

### dynamic_cast Operator
MSDN:
The expression dynamic_cast<type-id>( expression ) converts the operand expression to an object of type type-id. The type-id must be a pointer or a reference to a previously defined class type or a “pointer to void”. The type of expression must be a pointer if type-id is a pointer, or an l-value if type-id is a reference.
Syntax
dynamic_cast < type-id > ( expression )
If type-id is a pointer to an unambiguous accessible direct or indirect base class of expression, a pointer to the unique subobject of type type-id is the result. For example:

```
class B { ... };
class C : public B { ... };
class D : public C { ... };

void f(D* pd)
{
  C* pc = dynamic_cast<C*>(pd);   // ok: C is a direct base class
                          // pc points to C subobject of pd

  B* pb = dynamic_cast<B*>(pd);   // ok: B is an indirect base class
                          // pb points to B subobject of pd
  ...
}
```

This type of conversion is called an “upcast” because it moves a pointer up a class hierarchy, from a derived class to a class it is derived from. An upcast is an implicit conversion.
If type-id is void*, a run-time check is made to determine the actual type of expression. The result is a pointer to the complete object pointed to by expression. For example:
```
class A { ... };
class B { ... };
void f()
{
  A* pa = new A;
  B* pb = new B;
  void* pv = dynamic_cast<void*>(pa);
  // pv now points to an object of type A
  ...
  pv = dynamic_cast<void*>(pb);
  // pv now points to an object of type B
}
```

If type-id is not void*, a run-time check is made to see if the object pointed to by expression can be converted to the type pointed to by type-id.
If the type of expression is a base class of the type of type-id, a run-time check is made to see if expression actually points to a complete object of the type of type-id. If this is true, the result is a pointer to a complete object of the type of type-id. For example:
```
class B { ... };
class D : public B { ... };
void f()
{
  B* pb = new D;               // unclear but ok
  B* pb2 = new B;
  D* pd = dynamic_cast<D*>(pb);      // ok: pb actually points to a D
  D* pd2 = dynamic_cast<D*>(pb2);   //error: pb2 points to a B, not a D
                             // pd2 == NULL
}
```

This type of conversion is called a “downcast” because it moves a pointer down a class hierarchy, from a given class to a class derived from it.

>dynamic_cast，它被用于安全地沿着类的继承关系向下进行类型转换。这就是说，你能用dynamic_cast把指向基类的指针或引用转换成指向其派生类或其兄弟类的指针或引用，而且你能知道转换是否成功。失败的转换将返回空指针（当对指针进行类型转换时）或者抛出异常（当对引用进行类型转换时）。
dynamic_casts在帮助你浏览继承层次上是有限制的。它不能被用于缺乏虚函数的类型上，也不能用它来转换掉constness。即必须有RTTI或者叫virtual table

### reinterpret_cast Operator
MSDN:
The reinterpret_cast operator allows any pointer to be converted into any other pointer type. It also allows any integral type to be converted into any pointer type and vice versa. Misuse of the reinterpret_cast operator can easily be unsafe. Unless the desired conversion is inherently low-level, you should use one of the other cast operators.

Syntax
reinterpret_cast < type-id > ( expression )
The reinterpret_cast operator can be used for conversions such as char* to int*, or One_class* to Unrelated_class*, which are inherently unsafe.
The result of a reinterpret_cast cannot safely be used for anything other than being cast back to its original type. Other uses are, at best, nonportable.
The reinterpret_cast operator cannot cast away the const, volatile, or __unaligned attributes.

>使用这个操作符的类型转换，其的转换结果几乎都是执行期定义（implementation-defined）。因此，使用reinterpret_casts的代码很难移植。 reinterpret_casts的最普通的用途就是在函数指针类型之间进行转换。
比如转换函数指针的代码是不可移植的（C++不保证所有的函数指针都被用一样的方法表示），在一些情况下这样的转换会产生不正确的结果（参见条款M31），所以你应该避免转换函数指针类型。

如果你使用的编译器缺乏对新的类型转换方式的支持，你可以用传统的类型转换方法代替static_cast, const_cast, 以及reinterpret_cast。也可以用下面的宏替换来模拟新的类型转换语法：
```
#define static_cast(TYPE,EXPR)          ((TYPE)(EXPR))
#define const_cast(TYPE,EXPR)          ((TYPE)(EXPR))
#define reinterpret_cast(TYPE,EXPR)   ((TYPE)(EXPR))
```

这些模拟不会象真实的操作符一样安全，但是当你的编译器可以支持新的的类型转换时，它们可以简化你把代码升级的过程。

没有一个容易的方法来模拟dynamic_cast的操作，但是很多函数库提供了函数，安全地在派生类与基类之间进行类型转换。如果你没有这些函数而你有必须进行这样的类型转换，你也可以回到C风格的类型转换方法上，但是这样的话你将不能获知类型转换是否失败。当然，你也可以定义一个宏来模拟dynamic_cast的功能，就象模拟其它的类型转换一样：
```
#define dynamic_cast(TYPE,EXPR)     (TYPE)(EXPR)
```
请记住，这个模拟并不能完全实现dynamic_cast的功能，它没有办法知道转换是否失败。

## 利用运算符转换
当有合适的构造函数时，就不需要写太多不同类型的重载函数，编译器会调用合适的构造函数来隐式转化合适的类型, 隐式类型转换运算符是一种特殊的转换运算符:
如：
```
class Rational {
public:
operator double() const; // 把Rational类转换成double类型
}
```
一个例子:C++委员会加在库函数中的string类型没有包括隐式地从string转换成C风格的char*的功能，而是定义了一个成员函数c_str用来完成这个转换，这是巧合么？我看不是->**肯定是为了避免作隐式转换**


隐式类型转换
在D&E 3.6中提到，为string 增加了类型转换 operator char *(),后来又被放弃？

### conversion operators
参考
https://www.tutorialspoint.com/conversion-operators-in-cplusplus
```
operator  double  ()  {  
  //Conversion operator to gen magnitude  return getMagnitude();  
}
```




# string 相关
##	string.c_str()
vc调用这个:
```
const _Elem *_Myptr() const
{ // determine current pointer to buffer for nonmutable string
return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
  : this->_Bx._Buf);
}

实际上Bx是一个union,可以指向一个char buf[size],也可以是一个char*
union _Bxty
{ // storage for small buffer or pointer to larger one
_Elem _Buf[_BUF_SIZE];
_Elem *_Ptr;
char _Alias[_BUF_SIZE]; // to permit aliasing
} _Bx;
```

## string x;
string y =x;如何实现的？是否会引用？还是会copy?参考houjie的stl书
->调用copy ctor, vc++的好像需要拷贝该string.
```
_Myt& assign(const _Myt& _Right,size_type _Roff, size_type _Count)
  {	// assign _Right [_Roff, _Roff + _Count)
  if (_Right.size() < _Roff)
    _Xran();	// _Roff off end
  size_type _Num = _Right.size() - _Roff;
  if (_Count < _Num)
    _Num = _Count;	// trim _Num to size

  if (this == &_Right)
    erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
  else if (_Grow(_Num))
    {	// make room and assign new stuff
    _Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);
    _Eos(_Num);
    }
  return (*this);
  }	
```

对于GCC版本
```
_CharT*	_M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
{
  return (!_M_is_leaked() && __alloc1 == __alloc2)
          ? _M_refcopy() : _M_clone(__alloc1);
}
```

如果alloc1和alloc2是同一种allocator,那么就会使用refcopy
需要看一下vc和gcc不同的实现


## COW 多线程同步问题？
copy on write 多线程问题
但从不同线程中操作”独立“的string对象来看，std::string必须是线程安全的。
>这个角度不对，凡是问线程安全，必定指同一个对象，多线程中操作是否安全

咋一看这似乎不是要求，但COW的实现使两个逻辑上独立的string对象在物理上共享同一片内存，因此必须实现逻辑层面的隔离。C++0x草案(N2960)中就有这么一段：

The C++0x draft (N2960) contains the section "data race avoidance" which basically says that library components may access shared data that is hidden from the user if and only if it activly avoids possible data races.

COW会使用引用计数
```
string str1 = "abcdefg";
string str2 = str1;
printf ("\tstr1's address: %lx\n", (uint64_t)(str1.c_str()) );
printf ("\tstr2's address: %lx\n", (uint64_t)(str2.c_str()) );
```
使用g++4.9.3编译，地址一样

在这里面检查is_shared,然后复制原有的内存块。std::string::_M_leak_hard

问题:
str2和str1都指向同一块内存，位于两个不同的thread,当str2打算修改内存的时候,str1正巧也在修改内存值。这里是否有冲突?
->假设str1和str2指向内存0x1234,str1 若要修改内容的话，会注意到0x1234除开自己外已有reference count>=1，因此它会新建一个内存0x4567来保存新值。


## C++ 工程实践(10)：再探std::string
http://www.cnblogs.com/Solstice/archive/2012/03/17/2403335.html


std::string &get_str()
{
  std::string y="abcdefg";
  return y;
}
也不能返回local variable 的引用,会先~string然后再=的

string的= 是如何处理引用的,估计是引用,指向同一段内存,需要修改之后再分配新的内存

```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <string>
class base {
public:
  int x;
};
class derived:public base {
public:
  int y;
};
std::string get_string() {
  char *buf=(char*)malloc(10);
  strcpy(buf,"abcd");
  return buf;
}
void strtest() {
  std::string a = "A medium-sized string to avoid SSO";
  std::string b = a;
  int a1= (a.data() == b.data());
  b.append("A");
  int b1 = (a.data() == b.data());
  int x=1;
}
int main()
{
  strtest();
  std::string xx=get_string();
  base *ptr=new base;
  ptr->x=10;
  derived *ptr2=static_cast<derived*>(ptr);
  ptr2->y=20;
}
```

**string的格式化**
string转换为int (sstream)
string hourstr = input.substr(0, 2);
int hour;
stringstream ss(hourstr);
ss >> hour;

**reset stringstream**
ss.str(“”);
ss.clear();

**实现**
参考chensuo muduo 与linux网络编程, 3种实现:eager_copy,COW,SSO


#	IO相关
## 概述
chensuo 关于iostream中讲到:  scanf和printf的格式不统一，缓冲区溢出危险
basic_istream<>只是一个基类

继承关系class basic_ifstream : public basic_istream<_CharT, _Traits>
ios_base 的copy-ctor 和assignment是private的，所以禁止拷贝和赋值。
iostream禁止 assign 和copy ctor, 做法是声明这两个为private,或者=delete

istream 定义了input stream
ostream 定义了output stream

C++里对文件的支持有两个: <fstream>, 分别是ofstream和ifstream.
typedef basic_ifstream<char>  ifstream;

std::istream input = std::getline(csvfile, csvline);  //error

预定义的全局stream对象
cin,cout,cerr,clog
操作符 << >> 操作器manipulator endl, hex

这段代码用于while (std::getline(fp,str) 之类,用来判断stream 状态?
```
/**
       *  @brief  The quick-and-easy status check.
       *
       *  This allows you to write constructs such as
       *  "if (!a_stream) ..." and "while (a_stream) ..."
      */
operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }
```
##	cout格式化
cout.setf(ios::showpoint);
cout.precision(3);
cout.setf(ios::fixed);

保存小数点后3位
```
#include <iomanip>
补齐0
cout << setfill('0') << setw(2) << hour;
设置格式,16进制输出: fs << std::hex << flow
```
Cout如何格式化输出:showbase,hex,oct,dec等等


## 从console 读入并输出
```
std::string line;
while (std::getline(std::cin,line)) {        
  std::cout << line;
}
```
getline的默认分隔符是回车’\n’
cin>>line 会忽略空格
使用 cin.ignore(numeric_limits<streamsize>::max(), '\n'),意思是ignores the rest of the current line, up to '\n' or EOF - whichever comes first:


## 一个最基本的写文件的C++实现
```
std::ofstream g_xdrcsv;
g_xdrcsv.open(filename.c_str(), std::ios_base::out);
if (!g_xdrcsv) {
  std::cerr << "cannot open xdr csv file for output\n";
  return;
}
g_xdrcsv.close();
```

还有这个:
```
void logToFile(std::string str) {
	static std::ofstream ofs;
	std::string fileName = "c:\\talklog.txt";
	if (!ofs.is_open()) {
		ofs.open(fileName.c_str(), std::ios_base::out|std::ios_base::app);
		if (!ofs) {
			std::cerr << "cannot open log file\n";
			return;
		}
	}	
	ofs << str << std::endl;
	ofs.close();
}
```

c api难以处理不同的类型:
clock_t。这是 clock(3) 的返回类型
• dev_t。这是 mknod(3) 的参数类型
• in_addr_t、in_port_t。这是 struct sockaddr_in 的成员类型
• nfds_t。这是 poll(2) 的参数类型
• off_t。这是 lseek(2) 的参数类型，麻烦的是，这个类型与宏定义
_FILE_OFFSET_BITS 有关。
• pid_t、uid_t、gid_t。这是 getpid(2) getuid(2) getgid(2) 的返回类型

自定义类型的输出
```
std::ostream& operator<<(std::ostream& os, const Date& date){
  date.writeTo(os);
  return os;
}
```

## stream使用
主要有fstream,ifstream和ofstream
ofstream是从内存到硬盘，ifstream是从硬盘到内存，其实所谓的流缓冲就是内存空间;
在C++中，有一个stream这个类，所有的I/O都以这个“流”类为基础的，包括我们要认识的文件I/O，stream这个类有两个重要的运算符：
插入器(<<)　　向流输出数据。比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout<<"Write Stdout"<<'\n';就表示把字符串"Write Stdout"和换行字符('\n')输出到标准输出流。
析取器(>>)　　从流中输入数据。比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin>>x;就表示从标准输入流中读取一个指定类型(即变量x的类型)的数据。
　　在C++中，对文件的操作是通过stream的子类fstream(file stream)来实现的，所以，要用这种方式操作文件，就必须加入头文件fstream.h。下面就把此类的文件操作过程一一道来。
一、打开文件
　　在fstream类中，有一个成员函数open()，就是用来打开文件的，其原型是：
 void open(const char* filename,int mode,int access);
参数：
filename：　　要打开的文件名
mode：　　　　要打开文件的方式
access：　　　打开文件的属性
打开文件的方式在类ios(是所有流式I/O类的基类)中定义，常用的值如下：
ios::app：　　　以追加的方式打开文件
ios::ate：　　　文件打开后定位到文件尾，ios:app就包含有此属性
ios::binary：　以二进制方式打开文件，缺省的方式是文本方式。两种方式的区别见前文
ios::in：　　　文件以输入方式打开（文件数据输入到内存）
ios::out：　　　文件以输出方式打开（内存数据输出到文件）
ios::nocreate：不建立文件，所以文件不存在时打开失败
ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败
ios::trunc：　　如果文件存在，把文件长度设为0
　　可以用“或”把以上属性连接起来，如ios::out|ios::binary
　　打开文件的属性取值是：
0：普通文件，打开访问
1：只读文件
2：隐含文件
4：系统文件
　　可以用“或”或者“+”把以上属性连接起来，如3或1|2就是以只读和隐含属性打开文件。
　　例如：以二进制输入方式打开文件c:\config.sys
 fstream file1; 
 file1.open("c:\\config.sys",ios::binary|ios::in,0); 
　　如果open函数只有文件名一个参数，则是以读/写普通文件打开，即：
file1.open("c:\\config.sys"); <=> file1.open("c:\\config.sys",ios::in|ios::out,0);
　　另外，fstream还有和open()一样的构造函数，对于上例，在定义的时侯就可以打开文件了：
 fstream file1("c:\\config.sys");
　　特别提出的是，fstream有两个子类：ifstream(input file stream)和ofstream(outpu file stream)，ifstream默认以输入方式打开文件，而ofstream默认以输出方式打开文件。
 ifstream file2("c:\\pdos.def");//以输入方式打开文件 
 ofstream file3("c:\\x.123");//以输出方式打开文件
　　所以，在实际应用中，根据需要的不同，选择不同的类来定义：如果想以输入方式打开，就用ifstream来定义；如果想以输出方式打开，就用ofstream来定义；如果想以输入/输出方式来打开，就用fstream来定义。
二、关闭文件
　　打开的文件使用完成后一定要关闭，fstream提供了成员函数close()来完成此操作，如：file1.close();就把file1相连的文件关闭。
三、读写文件
　　读写文件分为文本文件和二进制文件的读取，对于文本文件的读取比较简单，用插入器和析取器就可以了；而对于二进制的读取就要复杂些，下要就详细的介绍这两种方式
　　1、文本文件的读写
　　文本文件的读写很简单：用插入器(<<)向文件输出；用析取器(>>)从文件输入。假设file1是以输入方式打开，file2以输出打开。示例如下：
　　
 file2<<"I Love You";//向文件写入字符串"I Love You" 
 int i; 
 file1>>i;//从文件输入一个整数值。 
　　这种方式还有一种简单的格式化能力，比如可以指定输出为16进制等等，具体的格式有以下一些
操纵符功能输入/输出
dec 格式化为十进制数值数据输入和输出
endl 输出一个换行符并刷新此流输出
ends 输出一个空字符输出
hex 格式化为十六进制数值数据输入和输出
oct 格式化为八进制数值数据输入和输出
setpxecision(int p) 设置浮点数的精度位数输出
　　比如要把123当作十六进制输出：file1<<hex<<123;要把3.1415926以5位精度输出：file1<<setpxecision(5)<<3.1415926。
　　2、二进制文件的读写
①put()
　　put()函数向流写入一个字符，其原型是ofstream &put(char ch)，使用也比较简单，如file1.put('c');就是向流写一个字符'c'。
②get()
　　get()函数比较灵活，有3种常用的重载形式：
　　一种就是和put()对应的形式：ifstream &get(char &ch);功能是从流中读取一个字符，结果保存在引用ch中，如果到文件尾，返回空字符。如file2.get(x);表示从文件中读取一个字符，并把读取的字符保存在x中。
　　另一种重载形式的原型是： int get();这种形式是从流中返回一个字符，如果到达文件尾，返回EOF，如x=file2.get();和上例功能是一样的。
　　还有一种形式的原型是：ifstream &get(char *buf,int num,char delim='\n')；这种形式把字符读入由 buf 指向的数组，直到读入了 num 个字符或遇到了由 delim 指定的字符，如果没使用 delim 这个参数，将使用缺省值换行符'\n'。例如：　　
 file2.get(str1,127,'A');     //从文件中读取字符到字符串str1，当遇到字符'A'或读取了127个字符时终止。 
③读写数据块
　　要读写二进制数据块，使用成员函数read()和write()成员函数，它们原型如下：　　　　
 read(unsigned char *buf,int num); 
 write(const unsigned char *buf,int num); 
　　read()从文件中读取 num 个字符到 buf 指向的缓存中，如果在还未读入 num 个字符时就到了文件尾，可以用成员函数 int gcount();来取得实际读取的字符数；而 write() 从buf 指向的缓存写 num 个字符到文件中，值得注意的是缓存的类型是 unsigned char *，有时可能需要类型转换。
例：
　　　　
 unsigned char str1[]="I Love You";    
 int n[5];    
 ifstream in("xxx.xxx");    
 ofstream out("yyy.yyy");    
 out.write(str1,strlen(str1));//把字符串str1全部写到yyy.yyy中    
 in.read((unsigned char*)n,sizeof(n));//从xxx.xxx中读取指定个整数，注意类型转换    
 in.close();out.close();
四、检测EOF
　　成员函数eof()用来检测是否到达文件尾，如果到达文件尾返回非0值，否则返回0。原型是int eof();
例：　　if(in.eof())   ShowMessage("已经到达文件尾！");
五、文件定位
　　和C的文件操作方式不同的是，C++ I/O系统管理两个与一个文件相联系的指针。一个是读指针，它说明输入操作在文件中的位置；另一个是写指针，它下次写操作的位置。每次执行输入或输出时，相应的指针自动变化。所以，C++的文件定位分为读位置和写位置的定位，对应的成员函数是seekg()和seekp()。seekg()是设置读位置， seekp是设置写位置。它们最通用的形式如下：
　　　　istream &seekg(streamoff offset,seek_dir origin);
　　　　ostream &seekp(streamoff offset,seek_dir origin);
　　streamoff定义于 iostream.h 中，定义有偏移量 offset 所能取得的最大值，seek_dir 表示移动的基准位置，是一个有以下值的枚举：
ios::beg：　　文件开头
ios::cur：　　文件当前位置
ios::end：　　文件结尾
　　这两个函数一般用于二进制文件，因为文本文件会因为系统对字符的解释而可能与预想的值不同。例：
　　　
 file1.seekg(1234,ios::cur);     //把文件的读指针从当前位置向后移1234个字节 
 file2.seekp(1234,ios::beg);     //把文件的写指针从文件开头向后移1234个字节


## 生成文件
```
#include <cstdlib>
#include <ctime>
#include <fstream>
#include <iostream>

#define MAX_NUM_DATA 10000000

using namespace std;

double doubleRand( ) {
  return double(rand()) / (double(RAND_MAX) + 1.0);
}


int generatefile() {
  srand(static_cast<unsigned int>(clock( )));
  ofstream fd("./data.txt");
  for (int i = 0; i < MAX_NUM_DATA;) {
    int numberperline = doubleRand()*20;
    for (int j = 0; j < numberperline; j++) {
      fd << i++ << " ";
    }
    if (numberperline != 0)
      fd << "\n";
  }
  fd.close();
}

int main() {
  generatefile();
}
```

## split 分割字符串
```
/*
 * split string by delim
 * @param delim delimiter
 * @return token stored in vector<string>
 */
static std::vector<std::string> split(const std::string &s, char delim) {
    std::vector<std::string> elems;
    std::stringstream ss(s);
    std::string item;
    while (std::getline(ss, item, delim)) {
        elems.push_back(item);
    }
    return elems;
}
```
下面这个只能依靠空格来分割，(可能不支持)
~~需要查看stringstream是怎么样分割的~~
```
#include<iostream>
#include<sstream>
#include<string>
usingnamespace std;

int main()
{
    string s("Somewhere down the road");
    istringstream iss(s);

	do
	{
	    string sub;
	    iss >> sub;
	    cout <<"Substring: "<< sub << endl;
	}while(iss);
}
```

**getline 分隔符**
```
istream& getline (char* s, streamsize n );
istream& getline (char* s, streamsize n, char delim )

split string
std::stringstream ss(s);
std::string item;
while (std::getline(ss, item, delim)) {
  elems.push_back(item);
}
return elems;
```

## stringstream流
std::string x;
std::stringstream ss(x); // put string into stream
使用stringstream对象实现数据类型之间的转换, 比如int -> string, 整型转为string
```
std::ostringstream oss;
oss << plan.id_;  
std::string filter = "id=\"" + oss.str() + "\"";

#include <string>
#include <fstream>
#include <sstream>
#include <iostream>

using namespace std;

int main()
{ 
  ifstream ifile( "./data.txt" ); 
  ostringstream buf; 
  char ch; 
  while ( buf && ifile.get( ch )) 
    buf.put( ch ); 

  cout << buf.str() << endl;
}
```

1.11.8	ostream_iterator的使用TBD
std::copy(vec.begin(), vec.end(), std::ostream_iterator<int>(std::cout, " "));

## libc standard IO和UNIX 的 IO
参看linux system programming
fopen, fdopen, fread, 参数有r,w,r+,w+
fgets, 读取最多MAX_LINE个字符，直到遇到newline\n退出。
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE 200

int main(int argc, char* argv[])
{
  FILE* fp;
  char buffer[MAX_LINE];
  fp = fopen("test.txt", "r");
  if (fp == NULL)   {
        perror("File open");
        exit(1);
  }
  while (fgets(buffer, MAX_LINE, fp) != NULL)   {
      fputs(buffer, stdout);
  }
  return0;
}
```
fread读入二进制数据,可以参考capfile.hpp,同时支持diskfile和memfile
MAX_SIZE = 16384
```
  virtual bool Open(const char *name, const char *mode) {
    m_file = fopen(name, mode);
    return m_file;
  }

  virtual void Close() {
    if (m_file)
      fclose(m_file);
  }

  virtual size_t Read(void **buf, int size) {
    if (size > MAX_SIZE)
      return -1;

    size_t res = fread(m_buffer, 1, size, m_file);
    *buf = m_buffer;
    return res;
  }

  virtual size_t Write(void *buf, int size) {
    return fwrite(buf, 1, size, m_file);
  }
```
调用Read(xx),
```
    pkthdr *p = NULL;
    const u_int hdrsize = sizeof(pkthdr);
    if (m_file->Read((void **) &p, hdrsize) < hdrsize)
      return 0;
```
也可以一次性用fread读入比较大的数据,参看

最快的读取文件的方法
https://www.byvoid.com/blog/fast-readfile
```
const int MAXN = 10000000;
const int MAXS = 60*1024*1024;
int numbers[MAXN];
char buf[MAXS];
void fread_analyse()
{
    freopen("data.txt","rb",stdin);
    int len = fread(buf,1,MAXS,stdin);
    buf[len] = '\0';
    analyse(buf,len);
}
```

##	streambuf
std::streambuf
typedef basic_streambuf<char> streambuf;
low level raw data
https://stackoverflow.com/questions/8116541/what-exactly-is-streambuf-how-do-i-use-it



## 拷贝文件
比较臃肿的例子
```
const char* input_file = "/opt/webapps/xtreme/conf/config.cnf";
const char* temp_file = "/opt/webapps/xtreme/conf/temp_config.txt";
std::string search_string = "localhost";
std::string client_ip="127.0.0.1";
 //string replace_string = "MyPassword";
 std::string inbuf;
 std::ifstream stream(input_file,std::ios::in);
 std::ofstream outFile (temp_file, std::ios::out);
 while(!stream.eof()){
   getline(stream, inbuf);
   int spot = inbuf.find(search_string);
   if(spot >= 0){
     std::string tmpstring = inbuf.substr(0,spot);
     tmpstring += client_ip;
     tmpstring += inbuf.substr(spot+search_string.length(), inbuf.length());
     inbuf = tmpstring;
     //write into a file
     outFile << inbuf << std::endl;
   }
 }
   stream.close();
   outFile.close();
```


## 写文件性能比较
小文件时似乎mmap稍快

## manipulator
**endl**
http://www.cplusplus.com/reference/ostream/endl/
Inserts a new-line character and flushes the stream.

Question  47:  Which  of  the  following  statements  correctly  describe  functions  of  the 
endl manipulator for the ostream object cout in C++?
A.  It only flushes the standard output stream.
B.  It  puts  a  newline  character  into  the  standard  output  stream  and  flushes  the 
standard output stream.
C.  It puts an end-of-output character into the standard output stream. 
D.  It only puts a newline character into the standard output stream.
E.  It indicates end-of-output and closes the standard output stream.


operator >> <<可以带有manipulator参数
std::cin >> std::hex >> n;         // manipulator

获取当时位置
std::ostream::tellp
outfile.write ("This is an apple",16);
long pos = outfile.tellp();


get(input)
std::istream::tellg
streampos tellg();
int length = is.tellg();


# Other 
## 可变参数
```
void dpi_log(intlevel,constchar*fmt,...){
	if(level>dpi_log_level)
	  return;
	va_listap;
	charmsg[DPI_MAX_LOGMSG_LEN];

	va_start(ap,fmt);
	vsnprintf(msg,sizeof(msg),fmt,ap);
	va_end(ap);

	switch(level){
		case LOG_LEVEL_ERROR:
		  DPI_LOG_ERROR(msg);
		break;
		case LOG_LEVEL_WARN:
		  DPI_LOG_WARN(msg);
		break;
		case LOG_LEVEL_INFO:
		  DPI_LOG_INFO(msg);
		break;
		case LOG_LEVEL_DEBUG:
		  DPI_LOG_DEBUG(msg);
		break;
		case LOG_LEVEL_TRACE:
		  DPI_LOG_TRACE(msg);
		break;
		default:
		break;
	}
}
```


## Built-in类型
uintptr_t,uint32_t,uint64_t

## Const volatile 函数.
I won't change the value, but there is something out there that can.
You are making a promise to yourself that you won't change the value (const qualification) and requesting the compiler to keep its slimy hands off of this object and turn off all optimization (volatile qualification). Unfortunately, there is little standard among the compiler vendors when it comes to treating volatile fairly. And volatile is a hint to the compiler after all.

## 继承or functor
首先，用普通函数指针是必然会后悔的。代码如果不能结合数据，表达能力有限。
那么用抽象基类还是tr1::function? 抽象基类开销小些，但是侵入性的。tr1::function用起来更方便。但是如果要一次提供好几个callback，用抽象基类更方便。

这不是新事物。OOP里用聚合/继承/mixin作这种组合的多的是，用template只是一种新的实现手段。如其他人指出的，template主要的局限在于它没有late binding这一对OOP极其重要的特性。而相对的，template有代码简短，有类型检查，开销小等优点。
一般而言，越是在程序的高层，在模块接口处，越强调动态性；而在底层，在内部实现细节，可以牺牲一些动态性换取上述template的优点。shared_ptr<T>肯定是template的正确运用，而如果你把浏览器的界面语言也作为静态参数：Browser<UILanguage>，则肯定是不恰当的。

## 友元
```
class ExDer1 
{
public:
  friend int Der1Fn(){ return 0; }// ExBase::stat; }
};
```

这并不是声明ExDer1的成员函数，而是声明了一个全局函数，该全局函数是类的友元函数,居然可以把函数体写在类内部。



## 类型
typedef
using MY_TYPE = char;
MY_TYPE ch = ‘f’;

## 临时变量和const
Const
char* p = "test";实质指向一个const 的全局内存空间，应该写成const char *p=”test”;C++允许这一点是为了和C取得兼容，将来可能被抛弃.

const 对指针的修饰可以看EFC 03，简单讲从右侧读起：const int *p; pointer 指向const int数据。

默认参数-临时变量的开销
https://stackoverflow.com/questions/48881018/cost-of-default-parameters-in-c
Default parameters:
¨ Note that they are always passed. Poor design can thus be costly:
```
void doThat(const std::string& name = "Unnamed");  // Bad
const std::string defaultName = "Unnamed";
void doThat(const std::string& name = defaultName);  // Better
```

>In the first one, a temporary std::string is initialised from the literal "Unnamed" each time the function is called without an argument.
In the second case, the object defaultName is initialised once (per source file), and simply used on each call.
got


int i=12
const int ci=12
12本身不是const,是一个数值,i是一个object,ci是一个object,但不能vary value,他们都是lvalue,12是rvalue,

const -> non-const一般而言是非法的，例如:
```
inline const uint16_t& getDestPort() const {
  return m_destPort;   
}
```
必须在返回值里也添加const,否则出现 : error: invalid initialization of reference of type ‘uint16_t&’ from expression of type ‘const uint16_t’

这样的形式是不允许的，因为是const ，又返回了一个reference ?
std::list<Dimension>& Job::GetTranslatedDimension() const {
return lst_translated_dms_;
}

对于const的成员变量，可以在ctor里面initializer里初始化也可以在函数里初始化 ?
```
CAggregator::CAggregator()
:m_queueServer(CQueueServer<RecordType>::getInstance()),
m_procMgr(CAggProcMgr<RecordType>::getInstance())
{}
```

## 临时变量RVO和返回局部临时变量(tbd)

Smth 精华区

看了好久的标准，终于有点眉目了，由于英语的问题，理解不知是否准确：
首先，要考虑对引用的初始化，比如如下的语法，在标准中是错的：
int  i = 2;
double& rd3 = i;
但是改成
int i=2;
const double& rd3 = i;
ok，正确。
因为对引用的初始化ISO98是这么说的： (可以参考D&E p72)
A reference to type ``cv1 T1'' is initialized by an expression of type ``cv2 T2'' as follows:

情况一：If the initializer expression is an lvalue (but is not a bit-field), and ``cv1 T1'' is reference-compatible with ``cv2 T2,'' or
情况二：has a class type (i.e., T2 is a class type) and can be implicitly converted to an lvalue of type ``cv3 T3,'' where ``cv1 T1'' is reference-compatible with ``cv3 T3'' *
否则的话：

Otherwise, the reference shall be to a non-volatile const type (i.e., cv1 shall be const).

总结一下，就是如果初始化引用，必需右边要么是左值（lval)要么能有函数把它变成左值，否则在定义的时候就必需声明为常量引用形式：
const cv1 &t1 = cv2 t2;
那么，从函数中返回的object是否是lval呢？ISO98是这么规定的：
-1- Every expression is either an lvalue or an rvalue.

-2- An lvalue refers to an object or function. Some rvalue expressions --- those of class or cv-qualified class type --- also refer to objects.*

[Footnote: Expressions such as invocations of constructors and of functions that return a class type refer to objects, and the implementation can invoke a member function upon such objects, but the expressions are not lvalues. --- end foonote]
注意脚注，形如
class X;
X f();
的函数返回的对象内的成员函数允许你调用，（当然，也可以改变对象内部的数据），但是
在调用
g(f())
中，表达式f()不是左值（奇怪？但就是这么规定的），自然用f()来初始化函数调用时的
引用时，只能用const X&，不能用X&，但同时允许你进行
f() = y; //invoc X::operator =()
f().print();
等操作。

由此看来，这个现象是c++标准本身定义的行为，而不是依赖于编译器的。至于think in
c++中的那种说法，照那样理解在程序中不会出错，但是那么说本身是不准确的，个人认为。


## 定位new表达式
CPP primer,p347
允许程序员要求将对象创建在意分配好的内存中,
	char *arena = new char [10];
	Data *ptr = new (arena) Data("Qualsimo");


# 模版
必须是这种形式声明:
template <class Type>
class Queue:public vector<Type>

vector
构造函数vector<int> vec(5)	//size 为5
遍历vector<int>iterator iter=vec.begin()…..<vec.end()…..

Typedef char type_must_be_complete[ -1 ]; //无法编译
void test_scopearr(int x)
{
  typedefchar type_must_be_complete[ x>0?1:-1 ];
}//x必须是const,或者能在compile是具现，才能用于[]类型的声明中,不允许动态数组?
这样是可以的:
template<class T>inline  void checked_array_delete(T * x)
{
Typedefchar type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
delete [] x;
}

