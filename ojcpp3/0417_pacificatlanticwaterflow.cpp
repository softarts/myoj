#include <vector>
#include <iostream>
using namespace std;
/*
某个cell从四个方向出发，能否同时到达两个大洋？
此题作为面试题的话，有点复杂
解法有点背离visited的做法了,

8:54PM
*/
// 这个实现的问题在于 如果想在全局保留每个元素的结果，就必须在最顶层都实时更新
// 假如某个cell在两个方向 3-3,3-3,形成一种并查集，那么所有cell的结果都必须更新
// 因此解法2不保留全局的结果，而是每次都计算
// 猜测并查集的解法更好， 但是并查集也有问题， 4->3 流动可以，但是反过来不行
// 保留全局结果还是有问题， 有些在后面的数据可能未更新
// class Solution0 {
// public:
//     int dir[5]={0,1,0,-1,0};
//     int m,n;
//     vector<vector<int>> visited;    
//     vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
//         vector<vector<int>> ans;
//         vector<vector<int>>& grid = heights;
        
//         m=grid.size();
//         n=grid[0].size();
       
//         visited.resize(m, vector<int>(n,-1));  // init state = -1
//         // visited[0][n-1] = 3; //1|2;
//         // visited[m-1][0] = 3;
        
//         for (int i=0;i<m;i++) {
//             for (int j=0;j<n;j++) {
//                 // cout <<"ret "<< i << "," << j << "-->" << endl;
//                 visited[i][j]=-1;
//                 int ret = helper(i,j,grid[i][j],grid);
//                 // cout <<"ret "<< i << "," << j << "=" << visited[i][j] << endl;

//                 if (ret==3) {
//                     ans.push_back({i,j});
//                 }
//             }
//         }
//         return ans;
//     }
//     /*
//     -1 未访问 ?
//     0 去不了任何一个地方, 不能前进
//     1 到达 P
//     2 到达 A
//     3 到达两者
//     */

//     int helper(int r, int c, int prev, vector<vector<int>>& grid){
//         if (r<0 || c<0) {
//             return 1;
//         }

//         if (r>=m || c>=n) {
//             return 2;
//         }

//         int cur = grid[r][c];
//         if (cur>prev) {
//             return 0;
//         }
//         if (visited[r][c]!=-1) return visited[r][c];   

//         visited[r][c] = 0; // go nowhere

//         for (int d=0;d<4;d++) {
//             int nr = r+dir[d];
//             int nc = c+dir[d+1];
//             visited[r][c] |= helper(nr,nc,cur,grid);
//             cout << "debug "<< r << "," << c << "=" << visited[r][c] << " next "<< nr << "," << nc<< endl;
//             if (visited[r][c]==3) {
//                 break;
//             }
//         }
//         cout << r << "," << c << "=" << visited[r][c] << endl;
//         return visited[r][c];
//     }
// };

// 能否记录前面的结果
class Solution {
public:
    int dir[5]={0,1,0,-1,0};
    int m,n;
    vector<vector<int>> visited;    
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        vector<vector<int>> ans;
        vector<vector<int>>& grid = heights;
        
        m=grid.size();
        n=grid[0].size();       
        visited.resize(m, vector<int>(n,-1));  // init state = -1        
        for (int i=0;i<m;i++) {
            for (int j=0;j<n;j++) {
                if (helper(i,j,grid[i][j],grid)==3) {
                    ans.push_back({i,j});
                }
            }
        }
        return ans;
    }
    /*
    -1 未访问 ?
    0 去不了任何一个地方, 不能前进
    1 到达 P
    2 到达 A
    3 到达两者
    要反向赋值，4-3->到达， 所以3也要更新
    */

    int helper(int r, int c, int prev, vector<vector<int>>& grid){
        if (r<0 || c<0) {
            return 1;
        }

        if (r>=m || c>=n) {
            return 2;
        }

        int cur = grid[r][c];
        if (cur>prev) {
            return 0;
        }

        if (visited[r][c]!=-1) {
            return visited[r][c];
        }

        visited[r][c] = 0;   

        for (int d=0;d<4;d++) {
            int nr = r+dir[d];
            int nc = c+dir[d+1];
            visited[r][c] |= helper(nr,nc,cur,grid);
            // cout << "debug "<< r << "," << c << "=" << visited[r][c] << " next "<< nr << "," << nc<< endl;
            if (visited[r][c]==3) {
                break;
            }
        }
        int tmp = visited[r][c];
        visited[r][c] = -1;
        // cout << r << "," << c << "=" << tmp << endl;
        return tmp;
    }
};


/*
1
[[0,2,19,19,3,12,14,16,18,8,9,14,13,10,17,7,18,4,0,18,17,8,9],[2,1,10,3,6,14,2,7,7,9,18,5,19,13,13,6,14,4,18,3,0,15,0],[9,1,19,15,16,9,1,9,14,9,9,1,3,4,19,12,19,7,15,2,1,19,8],[2,18,3,7,14,5,6,6,19,14,8,19,5,5,19,11,1,18,2,14,19,4,12],[0,6,15,18,11,6,3,18,3,9,6,1,18,7,14,14,2,9,13,1,16,10,13],[6,0,16,9,1,19,8,17,19,16,8,10,17,8,12,19,13,6,13,11,7,19,14],[17,17,11,1,17,19,0,5,10,6,2,17,13,11,13,10,12,13,0,11,9,7,0],[1,5,17,9,14,9,18,3,11,4,6,5,6,15,18,3,2,14,13,11,14,9,11],[4,18,7,10,6,17,2,4,1,8,4,8,8,16,15,4,1,1,13,4,1,10,14],[2,7,6,18,13,2,14,6,2,11,11,19,17,16,19,4,1,7,10,14,2,0,2],[9,15,7,12,1,6,13,12,14,16,13,17,6,3,11,17,2,6,11,2,1,7,4],[1,0,12,4,2,18,17,3,14,4,19,2,5,0,9,3,16,4,3,4,18,18,15],[6,15,4,5,0,14,11,12,12,12,17,7,13,18,7,15,11,19,7,18,9,4,14],[17,14,18,0,11,6,18,2,13,16,4,13,2,13,5,10,16,3,2,8,6,9,6],[6,1,15,17,2,2,14,16,11,18,14,13,0,0,4,0,6,12,15,0,12,10,7],[15,2,14,17,0,19,19,10,15,12,19,11,8,10,6,10,6,19,15,15,15,6,7],[18,0,10,9,1,11,10,15,9,9,10,16,15,11,17,4,9,0,15,12,11,16,19],[2,4,17,14,1,10,19,6,11,11,4,13,0,9,9,6,3,5,18,16,8,7,17],[7,1,10,2,16,10,8,1,3,15,9,18,16,16,5,5,7,5,12,17,1,5,3],[18,16,14,8,7,3,15,15,12,16,12,16,5,15,19,12,16,0,8,9,4,12,0],[6,9,9,7,16,10,8,0,11,14,17,14,13,12,14,4,6,10,9,15,0,4,12],[12,13,19,14,13,11,4,12,8,8,11,13,11,17,4,12,16,5,1,1,1,10,0],[19,9,16,13,5,5,13,15,10,13,2,7,16,3,12,1,6,14,11,19,14,4,0],[2,3,6,5,16,6,14,4,12,4,4,9,3,0,14,16,16,7,17,15,12,10,4],[0,0,15,4,3,5,9,7,12,18,10,10,4,17,14,6,7,7,6,2,1,18,19],[7,13,8,2,18,4,10,17,18,18,16,11,11,5,1,17,7,7,12,1,8,9,9],[17,7,2,9,13,11,0,17,9,11,12,17,2,2,17,2,8,17,3,10,3,10,3]]
2
[[3,12,7,6,3,12,17,13,3,9,14,14,3,7,17,8,2,0,19,16,2,14,7,8,7,9,11,2,8,6,14,6,7,12,19],[16,4,0,3,3,6,8,15,19,2,10,17,6,9,12,5,11,12,19,11,15,10,12,8,0,15,11,3,8,1,16,19,16,1,5]]

*/